"use strict";function _defineProperty(t,i,e){return(i=_toPropertyKey(i))in t?Object.defineProperty(t,i,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[i]=e,t}function _toPropertyKey(t){var i=_toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}function _toPrimitive(t,i){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var s=e.call(t,i||"default");if("object"!=typeof s)return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===i?String:Number)(t)}!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).PictApplication=t()}}((function(){return function t(i,e,s){function o(a,r){if(!e[a]){if(!i[a]){var h="function"==typeof require&&require;if(!r&&h)return h(a,!0);if(n)return n(a,!0);var l=new Error("Cannot find module '"+a+"'");throw l.code="MODULE_NOT_FOUND",l}var c=e[a]={exports:{}};i[a][0].call(c.exports,(function(t){return o(i[a][1][t]||t)}),c,c.exports,t,i,e,s)}return e[a].exports}for(var n="function"==typeof require&&require,a=0;a<s.length;a++)o(s[a]);return o}({1:[function(t,i,e){i.exports={name:"fable-serviceproviderbase",version:"3.0.15",description:"Simple base classes for fable services.",main:"source/Fable-ServiceProviderBase.js",scripts:{start:"node source/Fable-ServiceProviderBase.js",test:"npx mocha -u tdd -R spec",tests:"npx mocha -u tdd --exit -R spec --grep",coverage:"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec",build:"npx quack build"},mocha:{diff:!0,extension:["js"],package:"./package.json",reporter:"spec",slow:"75",timeout:"5000",ui:"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},repository:{type:"git",url:"https://github.com/stevenvelozo/fable-serviceproviderbase.git"},keywords:["entity","behavior"],author:"Steven Velozo <steven@velozo.com> (http://velozo.com/)",license:"MIT",bugs:{url:"https://github.com/stevenvelozo/fable-serviceproviderbase/issues"},homepage:"https://github.com/stevenvelozo/fable-serviceproviderbase",devDependencies:{fable:"^3.0.143",quackage:"^1.0.33"}}},{}],2:[function(t,i,e){const s=t("../package.json");class o{constructor(t,i,e){"object"==typeof t&&t.isFable?this.connectFable(t):this.fable=!1,this._PackageFableServiceProvider=s,this.fable?(this.UUID=t.getUUID(),this.options="object"==typeof i?i:{}):(this.options="object"!=typeof t||t.isFable?"object"==typeof i?i:{}:t,this.UUID=`CORE-SVC-${Math.floor(89999*Math.random()+1e4)}`),this.serviceType=`Unknown-${this.UUID}`,this.Hash="string"==typeof e?e:this.fable||"string"!=typeof i?`${this.UUID}`:i}connectFable(t){if("object"!=typeof t||!t.isFable){let i=`Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof t}].}`;return console.log(i),new Error(i)}return this.fable||(this.fable=t),this.log||(this.log=this.fable.Logging),this.services||(this.services=this.fable.services),this.servicesMap||(this.servicesMap=this.fable.servicesMap),!0}}_defineProperty(o,"isFableService",!0),i.exports=o,i.exports.CoreServiceProviderBase=o},{"../package.json":1}],3:[function(t,i,e){i.exports={name:"pict-application",version:"1.0.25",description:"Application base class for a pict view-based application",main:"source/Pict-Application.js",scripts:{test:"npx mocha -u tdd -R spec",start:"node source/Pict-Application.js",coverage:"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec",build:"npx quack build","docker-dev-build":"docker build ./ -f Dockerfile_LUXURYCode -t pict-application-image:local","docker-dev-run":'docker run -it -d --name pict-application-dev -p 30001:8080 -p 38086:8086 -v "$PWD/.config:/home/coder/.config"  -v "$PWD:/home/coder/pict-application" -u "$(id -u):$(id -g)" -e "DOCKER_USER=$USER" pict-application-image:local',"docker-dev-shell":"docker exec -it pict-application-dev /bin/bash",tests:"npx mocha -u tdd --exit -R spec --grep",lint:"eslint source/**",types:"tsc -p ."},types:"types/source/Pict-Application.d.ts",repository:{type:"git",url:"git+https://github.com/stevenvelozo/pict-application.git"},author:"steven velozo <steven@velozo.com>",license:"MIT",bugs:{url:"https://github.com/stevenvelozo/pict-application/issues"},homepage:"https://github.com/stevenvelozo/pict-application#readme",devDependencies:{"@eslint/js":"^9.28.0","browser-env":"^3.3.0",eslint:"^9.28.0",pict:"^1.0.270","pict-provider":"^1.0.5","pict-view":"^1.0.60",quackage:"^1.0.41"},mocha:{diff:!0,extension:["js"],package:"./package.json",reporter:"spec",slow:"75",timeout:"5000",ui:"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},dependencies:{"fable-serviceproviderbase":"^3.0.15"}}},{}],4:[function(t,i,e){const s=t("fable-serviceproviderbase"),o=t("../package.json"),n={Name:"DefaultPictApplication",MainViewportViewIdentifier:"Default-View",MainViewportRenderableHash:!1,MainViewportDestinationAddress:!1,MainViewportDefaultDataAddress:!1,AutoSolveAfterInitialize:!0,AutoRenderMainViewportViewAfterInitialize:!0,AutoRenderViewsAfterInitialize:!1,AutoLoginAfterInitialize:!1,AutoLoadDataAfterLogin:!1,ConfigurationOnlyViews:[],Manifests:{},IdentifierAddressPrefix:"PICT-"};i.exports=class extends s{constructor(t,i,e){let s="object"==typeof t.settings.PictApplicationConfiguration?t.settings.PictApplicationConfiguration:{};super(t,Object.assign({},JSON.parse(JSON.stringify(n)),s,i),e),this.options,this.log,this.fable,this.UUID,this.Hash,this.servicesMap,this.serviceType="PictApplication",this._Package=o,this.pict=this.fable,this.AppData=this.fable.AppData,this.initializeTimestamp,this.lastSolvedTimestamp,this.lastLoginTimestamp,this.lastMarshalFromViewsTimestamp,this.lastMarshalToViewsTimestamp,this.lastAutoRenderTimestamp,this.lastLoadDataTimestamp;let a=Object.keys(this.options.Manifests);if(a.length>0)for(let t=0;t<a.length;t++){let i=a[t];this.fable.instantiateServiceProvider("Manifest",this.options.Manifests[i],i)}}onPreSolve(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`),!0}onPreSolveAsync(t){return this.onPreSolve(),t()}onBeforeSolve(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`),!0}onBeforeSolveAsync(t){return this.onBeforeSolve(),t()}onSolve(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`),!0}onSolveAsync(t){return this.onSolve(),t()}solve(){this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`);let t=Object.keys(this.pict.providers),i=[];for(let e=0;e<t.length;e++){let s=this.pict.providers[t[e]];s.options.AutoSolveWithApp&&i.push(s)}i.sort(((t,i)=>t.options.AutoSolveOrdinal-i.options.AutoSolveOrdinal));for(let t=0;t<i.length;t++)i[t].solve(i[t]);this.onBeforeSolve();let e=Object.keys(this.pict.views),s=[];for(let t=0;t<e.length;t++){let i=this.pict.views[e[t]];i.options.AutoInitialize&&s.push(i)}s.sort(((t,i)=>t.options.AutoInitializeOrdinal-i.options.AutoInitializeOrdinal));for(let t=0;t<s.length;t++)s[t].solve();return this.onSolve(),this.onAfterSolve(),this.lastSolvedTimestamp=this.fable.log.getTimeStamp(),!0}solveAsync(t){let i=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate");i.anticipate(this.onBeforeSolveAsync.bind(this));let e="function"==typeof t&&t;e||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),e=t=>{t&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${t}`,t)});let s=Object.keys(this.pict.providers),o=[];for(let t=0;t<s.length;t++){let i=this.pict.providers[s[t]];i.options.AutoSolveWithApp&&o.push(i)}o.sort(((t,i)=>t.options.AutoSolveOrdinal-i.options.AutoSolveOrdinal));for(let t=0;t<o.length;t++)i.anticipate(o[t].solveAsync.bind(o[t]));let n=Object.keys(this.pict.views),a=[];for(let t=0;t<n.length;t++){let i=this.pict.views[n[t]];i.options.AutoSolveWithApp&&a.push(i)}a.sort(((t,i)=>t.options.AutoSolveOrdinal-i.options.AutoSolveOrdinal));for(let t=0;t<a.length;t++)i.anticipate(a[t].solveAsync.bind(a[t]));i.anticipate(this.onSolveAsync.bind(this)),i.anticipate(this.onAfterSolveAsync.bind(this)),i.wait((t=>(this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`),this.lastSolvedTimestamp=this.fable.log.getTimeStamp(),e(t))))}onAfterSolve(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`),!0}onAfterSolveAsync(t){return this.onAfterSolve(),t()}onBeforeLoginAsync(t){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeLoginAsync:`),t()}onLoginAsync(t){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onLoginAsync:`),t()}loginAsync(t){const i=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate");let e=t;"function"!=typeof e&&(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),e=t=>{t&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync Auto Callback Error: ${t}`,t)}),i.anticipate(this.onBeforeLoginAsync.bind(this)),i.anticipate(this.onLoginAsync.bind(this)),i.anticipate(this.onAfterLoginAsync.bind(this)),this.options.AutoLoadDataAfterLogin&&i.anticipate((t=>{if(!this.isLoggedIn())return t();this.pict.LogNoisiness>1&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto loading data after login...`),this.loadDataAsync((i=>{t(i)}))})),i.wait((t=>(this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync() complete.`),this.lastLoginTimestamp=this.fable.log.getTimeStamp(),e(t))))}isLoggedIn(){return!0}onAfterLoginAsync(t){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterLoginAsync:`),t()}onBeforeLoadDataAsync(t){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeLoadDataAsync:`),t()}onLoadDataAsync(t){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onLoadDataAsync:`),t()}loadDataAsync(t){const i=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate");let e=t;"function"!=typeof e&&(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),e=t=>{t&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync Auto Callback Error: ${t}`,t)}),i.anticipate(this.onBeforeLoadDataAsync.bind(this));let s=Object.keys(this.pict.providers),o=[];for(let t=0;t<s.length;t++){let i=this.pict.providers[s[t]];i.options.AutoLoadDataWithApp&&o.push(i)}o.sort(((t,i)=>t.options.AutoLoadDataOrdinal-i.options.AutoLoadDataOrdinal));for(const t of o)i.anticipate(t.onBeforeLoadDataAsync.bind(t));i.anticipate(this.onLoadDataAsync.bind(this));for(const t of o)i.anticipate(t.onLoadDataAsync.bind(t));i.anticipate(this.onAfterLoadDataAsync.bind(this));for(const t of o)i.anticipate(t.onAfterLoadDataAsync.bind(t));i.wait((t=>(this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync() complete.`),this.lastLoadDataTimestamp=this.fable.log.getTimeStamp(),e(t))))}onAfterLoadDataAsync(t){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterLoadDataAsync:`),t()}onBeforeSaveDataAsync(t){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSaveDataAsync:`),t()}onSaveDataAsync(t){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSaveDataAsync:`),t()}saveDataAsync(t){const i=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate");let e=t;"function"!=typeof e&&(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),e=t=>{t&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync Auto Callback Error: ${t}`,t)}),i.anticipate(this.onBeforeSaveDataAsync.bind(this));let s=Object.keys(this.pict.providers),o=[];for(let t=0;t<s.length;t++){let i=this.pict.providers[s[t]];i.options.AutoSaveDataWithApp&&o.push(i)}o.sort(((t,i)=>t.options.AutoSaveDataOrdinal-i.options.AutoSaveDataOrdinal));for(const t of o)i.anticipate(t.onBeforeSaveDataAsync.bind(t));i.anticipate(this.onSaveDataAsync.bind(this));for(const t of o)i.anticipate(t.onSaveDataAsync.bind(t));i.anticipate(this.onAfterSaveDataAsync.bind(this));for(const t of o)i.anticipate(t.onAfterSaveDataAsync.bind(t));i.wait((t=>(this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync() complete.`),this.lastSaveDataTimestamp=this.fable.log.getTimeStamp(),e(t))))}onAfterSaveDataAsync(t){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSaveDataAsync:`),t()}onBeforeInitialize(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`),!0}onBeforeInitializeAsync(t){return this.onBeforeInitialize(),t()}onInitialize(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`),!0}onInitializeAsync(t){return this.onInitialize(),t()}initialize(){if(this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`),this.initializeTimestamp)return this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`),!1;{if(this.onBeforeInitialize(),"ConfigurationOnlyViews"in this.options)for(let t=0;t<this.options.ConfigurationOnlyViews.length;t++){let i=void 0===this.options.ConfigurationOnlyViews[t].ViewIdentifier?`AutoView-${this.fable.getUUID()}`:this.options.ConfigurationOnlyViews[t].ViewIdentifier;this.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${i}`),this.pict.addView(i,this.options.ConfigurationOnlyViews[t])}this.onInitialize();let t=Object.keys(this.pict.providers),i=[];for(let e=0;e<t.length;e++){let s=this.pict.providers[t[e]];s.options.AutoInitialize&&i.push(s)}i.sort(((t,i)=>t.options.AutoInitializeOrdinal-i.options.AutoInitializeOrdinal));for(let t=0;t<i.length;t++)i[t].initialize();let e=Object.keys(this.pict.views),s=[];for(let t=0;t<e.length;t++){let i=this.pict.views[e[t]];i.options.AutoInitialize&&s.push(i)}s.sort(((t,i)=>t.options.AutoInitializeOrdinal-i.options.AutoInitializeOrdinal));for(let t=0;t<s.length;t++)s[t].initialize();return this.onAfterInitialize(),this.options.AutoSolveAfterInitialize&&(this.pict.LogNoisiness>1&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`),this.solve()),this.options.AutoRenderMainViewportViewAfterInitialize&&(this.pict.LogNoisiness>1&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`),this.render()),this.initializeTimestamp=this.fable.log.getTimeStamp(),!0}}initializeAsync(t){this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);let i="function"==typeof t&&t;if(i||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),i=t=>{t&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${t}`,t)}),this.initializeTimestamp)return this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`),i();{let t=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate");if(this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`),"ConfigurationOnlyViews"in this.options)for(let t=0;t<this.options.ConfigurationOnlyViews.length;t++){let i=void 0===this.options.ConfigurationOnlyViews[t].ViewIdentifier?`AutoView-${this.fable.getUUID()}`:this.options.ConfigurationOnlyViews[t].ViewIdentifier;this.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${i}`),this.pict.addView(i,this.options.ConfigurationOnlyViews[t])}t.anticipate(this.onBeforeInitializeAsync.bind(this)),t.anticipate(this.onInitializeAsync.bind(this));let e=Object.keys(this.pict.providers),s=[];for(let t=0;t<e.length;t++){let i=this.pict.providers[e[t]];i.options.AutoInitialize&&s.push(i)}s.sort(((t,i)=>t.options.AutoInitializeOrdinal-i.options.AutoInitializeOrdinal));for(let i=0;i<s.length;i++)t.anticipate(s[i].initializeAsync.bind(s[i]));let o=Object.keys(this.pict.views),n=[];for(let t=0;t<o.length;t++){let i=this.pict.views[o[t]];i.options.AutoInitialize&&n.push(i)}n.sort(((t,i)=>t.options.AutoInitializeOrdinal-i.options.AutoInitializeOrdinal));for(let i=0;i<n.length;i++){let e=n[i];t.anticipate(e.initializeAsync.bind(e))}t.anticipate(this.onAfterInitializeAsync.bind(this)),this.options.AutoLoginAfterInitialize&&(this.pict.LogNoisiness>1&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`),t.anticipate(this.loginAsync.bind(this))),this.options.AutoSolveAfterInitialize&&(this.pict.LogNoisiness>1&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`),t.anticipate(this.solveAsync.bind(this))),this.options.AutoRenderMainViewportViewAfterInitialize&&(this.pict.LogNoisiness>1&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`),t.anticipate(this.renderMainViewportAsync.bind(this))),t.wait((t=>(t&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Error: ${t.message||t}`,{stack:t.stack}),this.initializeTimestamp=this.fable.log.getTimeStamp(),this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`),i())))}}onAfterInitialize(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`),!0}onAfterInitializeAsync(t){return this.onAfterInitialize(),t()}onBeforeMarshalFromViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`),!0}onBeforeMarshalFromViewsAsync(t){return this.onBeforeMarshalFromViews(),t()}onMarshalFromViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`),!0}onMarshalFromViewsAsync(t){return this.onMarshalFromViews(),t()}marshalFromViews(){this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`),this.onBeforeMarshalFromViews();let t=Object.keys(this.pict.views),i=[];for(let e=0;e<t.length;e++){let s=this.pict.views[t[e]];i.push(s)}for(let t=0;t<i.length;t++)i[t].marshalFromView();return this.onMarshalFromViews(),this.onAfterMarshalFromViews(),this.lastMarshalFromViewsTimestamp=this.fable.log.getTimeStamp(),!0}marshalFromViewsAsync(t){let i=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate"),e="function"==typeof t&&t;e||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),e=t=>{t&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${t}`,t)}),i.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));let s=Object.keys(this.pict.views),o=[];for(let t=0;t<s.length;t++){let i=this.pict.views[s[t]];o.push(i)}for(let t=0;t<o.length;t++)i.anticipate(o[t].marshalFromViewAsync.bind(o[t]));i.anticipate(this.onMarshalFromViewsAsync.bind(this)),i.anticipate(this.onAfterMarshalFromViewsAsync.bind(this)),i.wait((t=>(this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`),this.lastMarshalFromViewsTimestamp=this.fable.log.getTimeStamp(),e(t))))}onAfterMarshalFromViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`),!0}onAfterMarshalFromViewsAsync(t){return this.onAfterMarshalFromViews(),t()}onBeforeMarshalToViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`),!0}onBeforeMarshalToViewsAsync(t){return this.onBeforeMarshalToViews(),t()}onMarshalToViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`),!0}onMarshalToViewsAsync(t){return this.onMarshalToViews(),t()}marshalToViews(){this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`),this.onBeforeMarshalToViews();let t=Object.keys(this.pict.views),i=[];for(let e=0;e<t.length;e++){let s=this.pict.views[t[e]];i.push(s)}for(let t=0;t<i.length;t++)i[t].marshalToView();return this.onMarshalToViews(),this.onAfterMarshalToViews(),this.lastMarshalToViewsTimestamp=this.fable.log.getTimeStamp(),!0}marshalToViewsAsync(t){let i=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate"),e="function"==typeof t&&t;e||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),e=t=>{t&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${t}`,t)}),i.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));let s=Object.keys(this.pict.views),o=[];for(let t=0;t<s.length;t++){let i=this.pict.views[s[t]];o.push(i)}for(let t=0;t<o.length;t++)i.anticipate(o[t].marshalToViewAsync.bind(o[t]));i.anticipate(this.onMarshalToViewsAsync.bind(this)),i.anticipate(this.onAfterMarshalToViewsAsync.bind(this)),i.wait((t=>(this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`),this.lastMarshalToViewsTimestamp=this.fable.log.getTimeStamp(),e(t))))}onAfterMarshalToViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`),!0}onAfterMarshalToViewsAsync(t){return this.onAfterMarshalToViews(),t()}onBeforeRender(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeRender:`),!0}onBeforeRenderAsync(t){return this.onBeforeRender(),t()}render(t,i,e,s){let o="string"!=typeof t?this.options.MainViewportViewIdentifier:t,n="string"!=typeof i?this.options.MainViewportRenderableHash:i,a="string"!=typeof e?this.options.MainViewportDestinationAddress:e,r="string"!=typeof s?this.options.MainViewportDefaultDataAddress:s;this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${n}] Destination[${a}] TemplateDataAddress[${r}] render:`),this.onBeforeRender();let h="string"==typeof o&&this.servicesMap.PictView[o];return h?(this.onRender(),h.render(n,a,r),this.onAfterRender(),!0):(this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${o} because it is not a valid view.`),!1)}onRender(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onRender:`),!0}onRenderAsync(t){return this.onRender(),t()}renderAsync(t,i,e,s,o){let n="string"!=typeof t?this.options.MainViewportViewIdentifier:t,a="string"!=typeof i?this.options.MainViewportRenderableHash:i,r="string"!=typeof e?this.options.MainViewportDestinationAddress:e,h="string"!=typeof s?this.options.MainViewportDefaultDataAddress:s,l="function"==typeof o?o:"function"==typeof s?s:"function"==typeof e?e:"function"==typeof i?i:"function"==typeof t&&t;l||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),l=t=>{t&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${t}`,t)}),this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${a}] Destination[${r}] TemplateDataAddress[${h}] renderAsync:`);let c=this.fable.newAnticipate();c.anticipate(this.onBeforeRenderAsync.bind(this));let p="string"==typeof n&&this.servicesMap.PictView[n];if(!p){let t=`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${n} because it is not a valid view.`;return this.pict.LogNoisiness>3&&this.log.error(t),l(new Error(t))}return c.anticipate(this.onRenderAsync.bind(this)),c.anticipate((t=>{p.renderAsync.call(p,a,r,h,t)})),c.anticipate(this.onAfterRenderAsync.bind(this)),c.wait(l)}onAfterRender(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterRender:`),!0}onAfterRenderAsync(t){return this.onAfterRender(),t()}renderMainViewport(){return this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`),this.render()}renderMainViewportAsync(t){return this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`),this.renderAsync(t)}renderAutoViews(){this.pict.LogNoisiness>0&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);let t=Object.keys(this.pict.views);t.sort(((t,i)=>this.pict.views[t].options.AutoRenderOrdinal-this.pict.views[i].options.AutoRenderOrdinal));for(let i=0;i<t.length;i++){let e=this.pict.views[t[i]];e.options.AutoRender&&e.render()}this.pict.LogNoisiness>0&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`)}renderAutoViewsAsync(t){let i=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate"),e="function"==typeof t&&t;e||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),e=t=>{t&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${t}`,t)}),this.pict.LogNoisiness>0&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);let s=Object.keys(this.pict.views);s.sort(((t,i)=>this.pict.views[t].options.AutoRenderOrdinal-this.pict.views[i].options.AutoRenderOrdinal));for(let t=0;t<s.length;t++){let e=this.pict.views[s[t]];e.options.AutoRender&&i.anticipate(e.renderAsync.bind(e))}i.wait((t=>(this.lastAutoRenderTimestamp=this.fable.log.getTimeStamp(),this.pict.LogNoisiness>0&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`),e(t))))}get isPictApplication(){return!0}}},{"../package.json":3,"fable-serviceproviderbase":2}]},{},[4])(4)}));
//# sourceMappingURL=pict-application.min.js.map
