"use strict";function _defineProperty(i,t,e){return(t=_toPropertyKey(t))in i?Object.defineProperty(i,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):i[t]=e,i}function _toPropertyKey(i){var t=_toPrimitive(i,"string");return"symbol"==typeof t?t:t+""}function _toPrimitive(i,t){if("object"!=typeof i||!i)return i;var e=i[Symbol.toPrimitive];if(void 0!==e){var s=e.call(i,t||"default");if("object"!=typeof s)return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(i)}!function(i){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=i();else if("function"==typeof define&&define.amd)define([],i);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).PictApplication=i()}}((function(){return function i(t,e,s){function o(a,r){if(!e[a]){if(!t[a]){var h="function"==typeof require&&require;if(!r&&h)return h(a,!0);if(n)return n(a,!0);var l=new Error("Cannot find module '"+a+"'");throw l.code="MODULE_NOT_FOUND",l}var p=e[a]={exports:{}};t[a][0].call(p.exports,(function(i){return o(t[a][1][i]||i)}),p,p.exports,i,t,e,s)}return e[a].exports}for(var n="function"==typeof require&&require,a=0;a<s.length;a++)o(s[a]);return o}({1:[function(i,t,e){t.exports={name:"fable-serviceproviderbase",version:"3.0.15",description:"Simple base classes for fable services.",main:"source/Fable-ServiceProviderBase.js",scripts:{start:"node source/Fable-ServiceProviderBase.js",test:"npx mocha -u tdd -R spec",tests:"npx mocha -u tdd --exit -R spec --grep",coverage:"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec",build:"npx quack build"},mocha:{diff:!0,extension:["js"],package:"./package.json",reporter:"spec",slow:"75",timeout:"5000",ui:"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},repository:{type:"git",url:"https://github.com/stevenvelozo/fable-serviceproviderbase.git"},keywords:["entity","behavior"],author:"Steven Velozo <steven@velozo.com> (http://velozo.com/)",license:"MIT",bugs:{url:"https://github.com/stevenvelozo/fable-serviceproviderbase/issues"},homepage:"https://github.com/stevenvelozo/fable-serviceproviderbase",devDependencies:{fable:"^3.0.143",quackage:"^1.0.33"}}},{}],2:[function(i,t,e){const s=i("../package.json");class o{constructor(i,t,e){"object"==typeof i&&i.isFable?this.connectFable(i):this.fable=!1,this._PackageFableServiceProvider=s,this.fable?(this.UUID=i.getUUID(),this.options="object"==typeof t?t:{}):(this.options="object"!=typeof i||i.isFable?"object"==typeof t?t:{}:i,this.UUID=`CORE-SVC-${Math.floor(89999*Math.random()+1e4)}`),this.serviceType=`Unknown-${this.UUID}`,this.Hash="string"==typeof e?e:this.fable||"string"!=typeof t?`${this.UUID}`:t}connectFable(i){if("object"!=typeof i||!i.isFable){let t=`Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof i}].}`;return console.log(t),new Error(t)}return this.fable||(this.fable=i),this.log||(this.log=this.fable.Logging),this.services||(this.services=this.fable.services),this.servicesMap||(this.servicesMap=this.fable.servicesMap),!0}}_defineProperty(o,"isFableService",!0),t.exports=o,t.exports.CoreServiceProviderBase=o},{"../package.json":1}],3:[function(i,t,e){t.exports={name:"pict-application",version:"1.0.24",description:"Application base class for a pict view-based application",main:"source/Pict-Application.js",scripts:{test:"npx mocha -u tdd -R spec",start:"node source/Pict-Application.js",coverage:"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec",build:"npx quack build","docker-dev-build":"docker build ./ -f Dockerfile_LUXURYCode -t pict-application-image:local","docker-dev-run":'docker run -it -d --name pict-application-dev -p 30001:8080 -p 38086:8086 -v "$PWD/.config:/home/coder/.config"  -v "$PWD:/home/coder/pict-application" -u "$(id -u):$(id -g)" -e "DOCKER_USER=$USER" pict-application-image:local',"docker-dev-shell":"docker exec -it pict-application-dev /bin/bash",tests:"npx mocha -u tdd --exit -R spec --grep",lint:"eslint source/**",types:"tsc -p ."},types:"types/source/Pict-Application.d.ts",repository:{type:"git",url:"git+https://github.com/stevenvelozo/pict-application.git"},author:"steven velozo <steven@velozo.com>",license:"MIT",bugs:{url:"https://github.com/stevenvelozo/pict-application/issues"},homepage:"https://github.com/stevenvelozo/pict-application#readme",devDependencies:{"@eslint/js":"^9.17.0","browser-env":"^3.3.0",eslint:"^9.17.0",pict:"^1.0.226","pict-view":"^1.0.55",quackage:"^1.0.36"},mocha:{diff:!0,extension:["js"],package:"./package.json",reporter:"spec",slow:"75",timeout:"5000",ui:"tdd","watch-files":["source/**/*.js","test/**/*.js"],"watch-ignore":["lib/vendor"]},dependencies:{"fable-serviceproviderbase":"^3.0.15"}}},{}],4:[function(i,t,e){const s=i("fable-serviceproviderbase"),o=i("../package.json"),n={Name:"DefaultPictApplication",MainViewportViewIdentifier:"Default-View",MainViewportRenderableHash:!1,MainViewportDestinationAddress:!1,MainViewportDefaultDataAddress:!1,AutoSolveAfterInitialize:!0,AutoRenderMainViewportViewAfterInitialize:!0,AutoRenderViewsAfterInitialize:!1,ConfigurationOnlyViews:[],Manifests:{},IdentifierAddressPrefix:"PICT-"};t.exports=class extends s{constructor(i,t,e){super(i,Object.assign({},JSON.parse(JSON.stringify(n)),t),e),this.options,this.log,this.fable,this.UUID,this.Hash,this.servicesMap,this.serviceType="PictApplication",this._Package=o,this.pict=this.fable,this.AppData=this.fable.AppData,this.initializeTimestamp,this.lastSolvedTimestamp,this.lastMarshalFromViewsTimestamp,this.lastMarshalToViewsTimestamp,this.lastAutoRenderTimestamp;let s=Object.keys(this.options.Manifests);if(s.length>0)for(let i=0;i<s.length;i++){let t=s[i];this.fable.instantiateServiceProvider("Manifest",this.options.Manifests[t],t)}}onPreSolve(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`),!0}onPreSolveAsync(i){return this.onPreSolve(),i()}onBeforeSolve(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`),!0}onBeforeSolveAsync(i){return this.onBeforeSolve(),i()}onSolve(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`),!0}onSolveAsync(i){return this.onSolve(),i()}solve(){this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`);let i=Object.keys(this.pict.providers),t=[];for(let e=0;e<i.length;e++){let s=this.pict.providers[i[e]];s.options.AutoSolveWithApp&&t.push(s)}t.sort(((i,t)=>i.options.AutoSolveOrdinal-t.options.AutoSolveOrdinal));for(let i=0;i<t.length;i++)t[i].solve(t[i]);this.onBeforeSolve();let e=Object.keys(this.pict.views),s=[];for(let i=0;i<e.length;i++){let t=this.pict.views[e[i]];t.options.AutoInitialize&&s.push(t)}s.sort(((i,t)=>i.options.AutoInitializeOrdinal-t.options.AutoInitializeOrdinal));for(let i=0;i<s.length;i++)s[i].solve();return this.onSolve(),this.onAfterSolve(),this.lastSolvedTimestamp=this.fable.log.getTimeStamp(),!0}solveAsync(i){let t=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate");t.anticipate(this.onBeforeSolveAsync.bind(this));let e="function"==typeof i&&i;e||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),e=i=>{i&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${i}`,i)});let s=Object.keys(this.pict.providers),o=[];for(let i=0;i<s.length;i++){let t=this.pict.providers[s[i]];t.options.AutoSolveWithApp&&o.push(t)}o.sort(((i,t)=>i.options.AutoSolveOrdinal-t.options.AutoSolveOrdinal));for(let i=0;i<o.length;i++)t.anticipate(o[i].solveAsync.bind(o[i]));let n=Object.keys(this.pict.views),a=[];for(let i=0;i<n.length;i++){let t=this.pict.views[n[i]];t.options.AutoSolveWithApp&&a.push(t)}a.sort(((i,t)=>i.options.AutoSolveOrdinal-t.options.AutoSolveOrdinal));for(let i=0;i<a.length;i++)t.anticipate(a[i].solveAsync.bind(a[i]));t.anticipate(this.onSolveAsync.bind(this)),t.anticipate(this.onAfterSolveAsync.bind(this)),t.wait((i=>(this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`),this.lastSolvedTimestamp=this.fable.log.getTimeStamp(),e(i))))}onAfterSolve(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`),!0}onAfterSolveAsync(i){return this.onAfterSolve(),i()}onBeforeInitialize(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`),!0}onBeforeInitializeAsync(i){return this.onBeforeInitialize(),i()}onInitialize(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`),!0}onInitializeAsync(i){return this.onInitialize(),i()}initialize(){if(this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`),this.initializeTimestamp)return this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`),!1;{if(this.onBeforeInitialize(),"ConfigurationOnlyViews"in this.options)for(let i=0;i<this.options.ConfigurationOnlyViews.length;i++){let t=void 0===this.options.ConfigurationOnlyViews[i].ViewIdentifier?`AutoView-${this.fable.getUUID()}`:this.options.ConfigurationOnlyViews[i].ViewIdentifier;this.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${t}`),this.pict.addView(t,this.options.ConfigurationOnlyViews[i])}this.onInitialize();let i=Object.keys(this.pict.providers),t=[];for(let e=0;e<i.length;e++){let s=this.pict.providers[i[e]];s.options.AutoInitialize&&t.push(s)}t.sort(((i,t)=>i.options.AutoInitializeOrdinal-t.options.AutoInitializeOrdinal));for(let i=0;i<t.length;i++)t[i].initialize();let e=Object.keys(this.pict.views),s=[];for(let i=0;i<e.length;i++){let t=this.pict.views[e[i]];t.options.AutoInitialize&&s.push(t)}s.sort(((i,t)=>i.options.AutoInitializeOrdinal-t.options.AutoInitializeOrdinal));for(let i=0;i<s.length;i++)s[i].initialize();return this.onAfterInitialize(),this.options.AutoSolveAfterInitialize&&(this.pict.LogNoisiness>1&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`),this.solve()),this.options.AutoRenderMainViewportViewAfterInitialize&&(this.pict.LogNoisiness>1&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`),this.render()),this.initializeTimestamp=this.fable.log.getTimeStamp(),!0}}initializeAsync(i){this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);let t="function"==typeof i&&i;if(t||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),t=i=>{i&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${i}`,i)}),this.initializeTimestamp)return this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`),t();{let i=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate");if(this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`),"ConfigurationOnlyViews"in this.options)for(let i=0;i<this.options.ConfigurationOnlyViews.length;i++){let t=void 0===this.options.ConfigurationOnlyViews[i].ViewIdentifier?`AutoView-${this.fable.getUUID()}`:this.options.ConfigurationOnlyViews[i].ViewIdentifier;this.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${t}`),this.pict.addView(t,this.options.ConfigurationOnlyViews[i])}i.anticipate(this.onBeforeInitializeAsync.bind(this)),i.anticipate(this.onInitializeAsync.bind(this));let e=Object.keys(this.pict.providers),s=[];for(let i=0;i<e.length;i++){let t=this.pict.providers[e[i]];t.options.AutoInitialize&&s.push(t)}s.sort(((i,t)=>i.options.AutoInitializeOrdinal-t.options.AutoInitializeOrdinal));for(let t=0;t<s.length;t++)i.anticipate(s[t].initializeAsync.bind(s[t]));let o=Object.keys(this.pict.views),n=[];for(let i=0;i<o.length;i++){let t=this.pict.views[o[i]];t.options.AutoInitialize&&n.push(t)}n.sort(((i,t)=>i.options.AutoInitializeOrdinal-t.options.AutoInitializeOrdinal));for(let t=0;t<n.length;t++){let e=n[t];i.anticipate(e.initializeAsync.bind(e))}i.anticipate(this.onAfterInitializeAsync.bind(this)),this.options.AutoSolveAfterInitialize&&(this.pict.LogNoisiness>1&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`),i.anticipate(this.solveAsync.bind(this))),this.options.AutoRenderMainViewportViewAfterInitialize&&(this.pict.LogNoisiness>1&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`),i.anticipate(this.renderMainViewportAsync.bind(this))),i.wait((i=>(i&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Error: ${i.message||i}`,{stack:i.stack}),this.initializeTimestamp=this.fable.log.getTimeStamp(),this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`),t())))}}onAfterInitialize(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`),!0}onAfterInitializeAsync(i){return this.onAfterInitialize(),i()}onBeforeMarshalFromViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`),!0}onBeforeMarshalFromViewsAsync(i){return this.onBeforeMarshalFromViews(),i()}onMarshalFromViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`),!0}onMarshalFromViewsAsync(i){return this.onMarshalFromViews(),i()}marshalFromViews(){this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`),this.onBeforeMarshalFromViews();let i=Object.keys(this.pict.views),t=[];for(let e=0;e<i.length;e++){let s=this.pict.views[i[e]];t.push(s)}for(let i=0;i<t.length;i++)t[i].marshalFromView();return this.onMarshalFromViews(),this.onAfterMarshalFromViews(),this.lastMarshalFromViewsTimestamp=this.fable.log.getTimeStamp(),!0}marshalFromViewsAsync(i){let t=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate"),e="function"==typeof i&&i;e||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),e=i=>{i&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${i}`,i)}),t.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));let s=Object.keys(this.pict.views),o=[];for(let i=0;i<s.length;i++){let t=this.pict.views[s[i]];o.push(t)}for(let i=0;i<o.length;i++)t.anticipate(o[i].marshalFromViewAsync.bind(o[i]));t.anticipate(this.onMarshalFromViewsAsync.bind(this)),t.anticipate(this.onAfterMarshalFromViewsAsync.bind(this)),t.wait((i=>(this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`),this.lastMarshalFromViewsTimestamp=this.fable.log.getTimeStamp(),e(i))))}onAfterMarshalFromViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`),!0}onAfterMarshalFromViewsAsync(i){return this.onAfterMarshalFromViews(),i()}onBeforeMarshalToViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`),!0}onBeforeMarshalToViewsAsync(i){return this.onBeforeMarshalToViews(),i()}onMarshalToViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`),!0}onMarshalToViewsAsync(i){return this.onMarshalToViews(),i()}marshalToViews(){this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`),this.onBeforeMarshalToViews();let i=Object.keys(this.pict.views),t=[];for(let e=0;e<i.length;e++){let s=this.pict.views[i[e]];t.push(s)}for(let i=0;i<t.length;i++)t[i].marshalToView();return this.onMarshalToViews(),this.onAfterMarshalToViews(),this.lastMarshalToViewsTimestamp=this.fable.log.getTimeStamp(),!0}marshalToViewsAsync(i){let t=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate"),e="function"==typeof i&&i;e||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),e=i=>{i&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${i}`,i)}),t.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));let s=Object.keys(this.pict.views),o=[];for(let i=0;i<s.length;i++){let t=this.pict.views[s[i]];o.push(t)}for(let i=0;i<o.length;i++)t.anticipate(o[i].marshalToViewAsync.bind(o[i]));t.anticipate(this.onMarshalToViewsAsync.bind(this)),t.anticipate(this.onAfterMarshalToViewsAsync.bind(this)),t.wait((i=>(this.pict.LogNoisiness>2&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`),this.lastMarshalToViewsTimestamp=this.fable.log.getTimeStamp(),e(i))))}onAfterMarshalToViews(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`),!0}onAfterMarshalToViewsAsync(i){return this.onAfterMarshalToViews(),i()}onBeforeRender(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeRender:`),!0}onBeforeRenderAsync(i){return this.onBeforeRender(),i()}render(i,t,e,s){let o="string"!=typeof i?this.options.MainViewportViewIdentifier:i,n="string"!=typeof t?this.options.MainViewportRenderableHash:t,a="string"!=typeof e?this.options.MainViewportDestinationAddress:e,r="string"!=typeof s?this.options.MainViewportDefaultDataAddress:s;this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${n}] Destination[${a}] TemplateDataAddress[${r}] render:`),this.onBeforeRender();let h="string"==typeof o&&this.servicesMap.PictView[o];return h?(this.onRender(),h.render(n,a,r),this.onAfterRender(),!0):(this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${o} because it is not a valid view.`),!1)}onRender(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onRender:`),!0}onRenderAsync(i){return this.onRender(),i()}renderAsync(i,t,e,s,o){let n="string"!=typeof i?this.options.MainViewportViewIdentifier:i,a="string"!=typeof t?this.options.MainViewportRenderableHash:t,r="string"!=typeof e?this.options.MainViewportDestinationAddress:e,h="string"!=typeof s?this.options.MainViewportDefaultDataAddress:s,l="function"==typeof o?o:"function"==typeof s?s:"function"==typeof e?e:"function"==typeof t?t:"function"==typeof i&&i;l||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),l=i=>{i&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${i}`,i)}),this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${a}] Destination[${r}] TemplateDataAddress[${h}] renderAsync:`);let p=this.fable.newAnticipate();p.anticipate(this.onBeforeRenderAsync.bind(this));let c="string"==typeof n&&this.servicesMap.PictView[n];if(!c){let i=`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${n} because it is not a valid view.`;return this.pict.LogNoisiness>3&&this.log.error(i),l(new Error(i))}return p.anticipate(this.onRenderAsync.bind(this)),p.anticipate((i=>{c.renderAsync.call(c,a,r,h,i)})),p.anticipate(this.onAfterRenderAsync.bind(this)),p.wait(l)}onAfterRender(){return this.pict.LogNoisiness>3&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterRender:`),!0}onAfterRenderAsync(i){return this.onAfterRender(),i()}renderMainViewport(){return this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`),this.render()}renderMainViewportAsync(i){return this.pict.LogControlFlow&&this.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`),this.renderAsync(i)}renderAutoViews(){this.pict.LogNoisiness>0&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);let i=Object.keys(this.pict.views);i.sort(((i,t)=>this.pict.views[i].options.AutoRenderOrdinal-this.pict.views[t].options.AutoRenderOrdinal));for(let t=0;t<i.length;t++){let e=this.pict.views[i[t]];e.options.AutoRender&&e.render()}this.pict.LogNoisiness>0&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`)}renderAutoViewsAsync(i){let t=this.fable.instantiateServiceProviderWithoutRegistration("Anticipate"),e="function"==typeof i&&i;e||(this.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`),e=i=>{i&&this.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${i}`,i)}),this.pict.LogNoisiness>0&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);let s=Object.keys(this.pict.views);s.sort(((i,t)=>this.pict.views[i].options.AutoRenderOrdinal-this.pict.views[t].options.AutoRenderOrdinal));for(let i=0;i<s.length;i++){let e=this.pict.views[s[i]];e.options.AutoRender&&t.anticipate(e.renderAsync.bind(e))}t.wait((i=>(this.lastAutoRenderTimestamp=this.fable.log.getTimeStamp(),this.pict.LogNoisiness>0&&this.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`),e(i))))}get isPictApplication(){return!0}}},{"../package.json":3,"fable-serviceproviderbase":2}]},{},[4])(4)}));
//# sourceMappingURL=pict-application.min.js.map
