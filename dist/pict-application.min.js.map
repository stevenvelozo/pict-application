{"version":3,"sources":["pict-application.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","source/Pict-Application.js"],"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","t","i","_toPrimitive","String","r","e","Symbol","toPrimitive","call","TypeError","Number","f","exports","module","define","amd","window","global","self","this","PictApplication","n","o","c","require","u","a","Error","code","p","length","FableServiceProviderBase","constructor","pFable","pOptions","pServiceHash","isFable","connectFable","fable","UUID","getUUID","options","concat","Math","floor","random","serviceType","Hash","tmpErrorMessage","console","log","Logging","services","servicesMap","CoreServiceProviderBase","libFableServiceBase","defaultPictSettings","Name","MainViewportViewIdentifier","MainViewportRenderableHash","MainViewportDestinationAddress","MainViewportDefaultDataAddress","AutoSolveAfterInitialize","AutoRenderMainViewportViewAfterInitialize","AutoRenderViewsAfterInitialize","Manifests","IdentifierAddressPrefix","super","assign","JSON","parse","stringify","pict","AppData","initializeTimestamp","lastSolvedTimestamp","lastMarshalFromViewsTimestamp","lastMarshalToViewsTimestamp","lastAutoRenderTimestamp","tmpManifestKeys","keys","tmpManifestKey","instantiateServiceProvider","onPreSolve","LogNoisiness","trace","onPreSolveAsync","fCallback","onBeforeSolve","onBeforeSolveAsync","onSolve","onSolveAsync","solve","tmpLoadedProviders","providers","tmpProvidersToSolve","tmpProvider","AutoSolveWithApp","push","sort","b","AutoSolveOrdinal","tmpLoadedViews","views","tmpViewsToSolve","tmpView","AutoInitialize","AutoInitializeOrdinal","onAfterSolve","getTimeStamp","solveAsync","tmpAnticipate","instantiateServiceProviderWithoutRegistration","anticipate","bind","tmpCallback","warn","pError","error","onAfterSolveAsync","wait","onBeforeInitialize","onBeforeInitializeAsync","onInitialize","onInitializeAsync","initialize","LogControlFlow","tmpProvidersToInitialize","tmpViewsToInitialize","onAfterInitialize","render","initializeAsync","onAfterInitializeAsync","renderMainViewportAsync","onBeforeMarshalFromViews","onBeforeMarshalFromViewsAsync","onMarshalFromViews","onMarshalFromViewsAsync","marshalFromViews","tmpViewsToMarshalFromViews","marshalFromView","onAfterMarshalFromViews","marshalFromViewsAsync","marshalFromViewAsync","onAfterMarshalFromViewsAsync","onBeforeMarshalToViews","onBeforeMarshalToViewsAsync","onMarshalToViews","onMarshalToViewsAsync","marshalToViews","tmpViewsToMarshalToViews","marshalToView","onAfterMarshalToViews","marshalToViewsAsync","marshalToViewAsync","onAfterMarshalToViewsAsync","pViewIdentifier","pRenderableHash","pRenderDestinationAddress","pTemplateDataAddress","tmpViewIdentifier","tmpRenderableHash","tmpRenderDestinationAddress","tmpTemplateDataAddress","PictView","renderMainViewport","renderAsync","renderAutoViews","AutoRenderOrdinal","AutoRender","renderAutoViewsAsync"],"mappings":"AAAA,aAEA,SAASA,gBAAgBC,EAAKC,EAAKC,GAA4L,OAAnLD,EAAME,eAAeF,MAAiBD,EAAOI,OAAOC,eAAeL,EAAKC,EAAK,CAAEC,MAAOA,EAAOI,YAAY,EAAMC,cAAc,EAAMC,UAAU,IAAkBR,EAAIC,GAAOC,EAAgBF,CAAK,CAC3O,SAASG,eAAeM,GAAK,IAAIC,EAAIC,aAAaF,EAAG,UAAW,MAAO,iBAAmBC,EAAIA,EAAIE,OAAOF,EAAI,CAC7G,SAASC,aAAaF,EAAGI,GAAK,GAAI,iBAAmBJ,IAAMA,EAAG,OAAOA,EAAG,IAAIK,EAAIL,EAAEM,OAAOC,aAAc,QAAI,IAAWF,EAAG,CAAE,IAAIJ,EAAII,EAAEG,KAAKR,EAAGI,GAAK,WAAY,GAAI,iBAAmBH,EAAG,OAAOA,EAAG,MAAM,IAAIQ,UAAU,+CAAiD,CAAE,OAAQ,WAAaL,EAAID,OAASO,QAAQV,EAAI,ECJvT,SAAAW,GAAA,GAAA,iBAAAC,SAAA,oBAAAC,OAAAA,OAAAD,QAAAD,SAAA,GAAA,mBAAAG,QAAAA,OAAAC,IAAAD,OAAA,GAAAH,OAAA,EAAA,oBAAAK,OAAAA,OAAA,oBAAAC,OAAAA,OAAA,oBAAAC,KAAAA,KAAAC,MAAAC,gBAAAT,GAAA,CAAA,CAAA,EAAA,WAAA,OAAA,SAAAP,EAAAC,EAAAgB,EAAArB,GAAA,SAAAsB,EAAArB,EAAAU,GAAA,IAAAU,EAAApB,GAAA,CAAA,IAAAI,EAAAJ,GAAA,CAAA,IAAAsB,EAAA,mBAAAC,SAAAA,QAAA,IAAAb,GAAAY,EAAA,OAAAA,EAAAtB,GAAA,GAAA,GAAAwB,EAAA,OAAAA,EAAAxB,GAAA,GAAA,IAAAyB,EAAA,IAAAC,MAAA,uBAAA1B,EAAA,KAAA,MAAAyB,EAAAE,KAAA,mBAAAF,CAAA,CAAA,IAAAG,EAAAR,EAAApB,GAAA,CAAAW,QAAA,CAAA,GAAAP,EAAAJ,GAAA,GAAAO,KAAAqB,EAAAjB,SAAA,SAAAR,GAAA,OAAAkB,EAAAjB,EAAAJ,GAAA,GAAAG,IAAAA,EAAA,GAAAyB,EAAAA,EAAAjB,QAAAR,EAAAC,EAAAgB,EAAArB,EAAA,CAAA,OAAAqB,EAAApB,GAAAW,OAAA,CAAA,IAAA,IAAAa,EAAA,mBAAAD,SAAAA,QAAAvB,EAAA,EAAAA,EAAAD,EAAA8B,OAAA7B,IAAAqB,EAAAtB,EAAAC,IAAA,OAAAqB,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAAE,EAAAX,EAAAD,GCKA,MAAAmB,EAKAC,WAAAA,CAAAC,EAAAC,EAAAC,GAGA,iBAAAF,GAAAA,EAAAG,QAEAjB,KAAAkB,aAAAJ,GAIAd,KAAAmB,OAAA,EAIAnB,KAAAmB,OAEAnB,KAAAoB,KAAAN,EAAAO,UACArB,KAAAsB,QAAA,iBAAAP,EAAAA,EACA,CAAA,IAMAf,KAAAsB,QAAA,iBAAAR,GAAAA,EAAAG,QACA,iBAAAF,EAAAA,EACA,CAAA,EAFAD,EAGAd,KAAAoB,KAAA,YAAAG,OAAAC,KAAAC,MAAA,MAAAD,KAAAE,SAAA,OAIA1B,KAAA2B,YAAA,WAAAJ,OAAAvB,KAAAoB,MAGApB,KAAA4B,KAAA,iBAAAZ,EAAAA,EACAhB,KAAAmB,OAAA,iBAAAJ,EAAA,GAAAQ,OACAvB,KAAAoB,MADAL,CAEA,CAEAG,YAAAA,CAAAJ,GAEA,GAAA,iBAAAA,IAAAA,EAAAG,QACA,CACA,IAAAY,EAAA,sHAAAN,cAAAT,EAAA,OAEA,OADAgB,QAAAC,IAAAF,GACA,IAAArB,MAAAqB,EACA,CAqBA,OAnBA7B,KAAAmB,QAEAnB,KAAAmB,MAAAL,GAGAd,KAAA+B,MAEA/B,KAAA+B,IAAA/B,KAAAmB,MAAAa,SAEAhC,KAAAiC,WAEAjC,KAAAiC,SAAAjC,KAAAmB,MAAAc,UAGAjC,KAAAkC,cAEAlC,KAAAkC,YAAAlC,KAAAmB,MAAAe,cAGA,CACA,EAGA/D,gBA3EAyC,EAAA,kBA0EA,GAGAlB,EAAAD,QAAAmB,EAGAlB,EAAAD,QAAA0C,wBAAAvB,CFEA,EAAE,CAAC,GAAG,EAAE,CAAC,SAASP,EAAQX,EAAOD,GGvFjC,MAAA2C,EAAA/B,EAAA,6BAEAgC,EACA,CACAC,KAAA,yBAGAC,2BAAA,eACAC,4BAAA,EACAC,gCAAA,EACAC,gCAAA,EAGAC,0BAAA,EACAC,2CAAA,EACAC,gCAAA,EAEAC,UAAA,CAAA,EAEAC,wBAAA,SAy1BArD,EAAAD,QAt1BA,cAAA2C,EAEAvB,WAAAA,CAAAC,EAAAC,EAAAC,GAGAgC,MAAAlC,EADAtC,OAAAyE,OAAA,CAAA,EAAAC,KAAAC,MAAAD,KAAAE,UAAAf,IAAAtB,GACAC,GACAhB,KAAA2B,YAAA,kBAGA3B,KAAAqD,KAAArD,KAAAmB,MAEAnB,KAAAsD,QAAAtD,KAAAmB,MAAAmC,QAEAtD,KAAAuD,qBAAA,EACAvD,KAAAwD,qBAAA,EACAxD,KAAAyD,+BAAA,EACAzD,KAAA0D,6BAAA,EACA1D,KAAA2D,yBAAA,EAGA,IAAAC,EAAApF,OAAAqF,KAAA7D,KAAAsB,QAAAwB,WACA,GAAAc,EAAAjD,OAAA,EAEA,IAAA,IAAA7B,EAAA,EAAAA,EAAA8E,EAAAjD,OAAA7B,IACA,CAEA,IAAAgF,EAAAF,EAAA9E,GACAkB,KAAAmB,MAAA4C,2BAAA,WAAA/D,KAAAsB,QAAAwB,UAAAgB,GAAAA,EACA,CAEA,CAKAE,UAAAA,GAMA,OAJAhE,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,kBAEA,CACA,CACA6B,eAAAA,CAAAC,GAGA,OADApE,KAAAgE,aACAI,GACA,CAEAC,aAAAA,GAMA,OAJArE,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,qBAEA,CACA,CACAgC,kBAAAA,CAAAF,GAGA,OADApE,KAAAqE,gBACAD,GACA,CAEAG,OAAAA,GAMA,OAJAvE,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,eAEA,CACA,CACAkC,YAAAA,CAAAJ,GAGA,OADApE,KAAAuE,UACAH,GACA,CAEAK,KAAAA,GAEAzE,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,mCAIA,IAAAoC,EAAAlG,OAAAqF,KAAA7D,KAAAqD,KAAAsB,WACAC,EAAA,GACA,IAAA,IAAA9F,EAAA,EAAAA,EAAA4F,EAAA/D,OAAA7B,IACA,CACA,IAAA+F,EAAA7E,KAAAqD,KAAAsB,UAAAD,EAAA5F,IACA+F,EAAAvD,QAAAwD,kBAEAF,EAAAG,KAAAF,EAEA,CAEAD,EAAAI,MAAA,CAAAzE,EAAA0E,IAAA1E,EAAAe,QAAA4D,iBAAAD,EAAA3D,QAAA4D,mBACA,IAAA,IAAApG,EAAA,EAAAA,EAAA8F,EAAAjE,OAAA7B,IAEA8F,EAAA9F,GAAA2F,MAAAG,EAAA9F,IAGAkB,KAAAqE,gBAEA,IAAAc,EAAA3G,OAAAqF,KAAA7D,KAAAqD,KAAA+B,OACAC,EAAA,GACA,IAAA,IAAAvG,EAAA,EAAAA,EAAAqG,EAAAxE,OAAA7B,IACA,CACA,IAAAwG,EAAAtF,KAAAqD,KAAA+B,MAAAD,EAAArG,IACAwG,EAAAhE,QAAAiE,gBAEAF,EAAAN,KAAAO,EAEA,CAEAD,EAAAL,MAAA,CAAAzE,EAAA0E,IAAA1E,EAAAe,QAAAkE,sBAAAP,EAAA3D,QAAAkE,wBACA,IAAA,IAAA1G,EAAA,EAAAA,EAAAuG,EAAA1E,OAAA7B,IAEAuG,EAAAvG,GAAA2F,QAKA,OAHAzE,KAAAuE,UACAvE,KAAAyF,eACAzF,KAAAwD,oBAAAxD,KAAAmB,MAAAY,IAAA2D,gBACA,CACA,CACAC,UAAAA,CAAAvB,GAEA,IAAAwB,EAAA5F,KAAAmB,MAAA0E,8CAAA,cAEAD,EAAAE,WAAA9F,KAAAsE,mBAAAyB,KAAA/F,OAIA,IAAAgG,EAAA,mBAAA5B,GAAAA,EAEA4B,IAEAhG,KAAA+B,IAAAkE,KAAA,YAAA1E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,2HACA0D,EAAAE,IAEAA,GAEAlG,KAAA+B,IAAAoE,MAAA,YAAA5E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,qCAAAf,OAAA2E,GAAAA,EACA,GAIA,IAAAxB,EAAAlG,OAAAqF,KAAA7D,KAAAqD,KAAAsB,WACAC,EAAA,GACA,IAAA,IAAA9F,EAAA,EAAAA,EAAA4F,EAAA/D,OAAA7B,IACA,CACA,IAAA+F,EAAA7E,KAAAqD,KAAAsB,UAAAD,EAAA5F,IACA+F,EAAAvD,QAAAwD,kBAEAF,EAAAG,KAAAF,EAEA,CAEAD,EAAAI,MAAA,CAAAzE,EAAA0E,IAAA1E,EAAAe,QAAA4D,iBAAAD,EAAA3D,QAAA4D,mBACA,IAAA,IAAApG,EAAA,EAAAA,EAAA8F,EAAAjE,OAAA7B,IAEA8G,EAAAE,WAAAlB,EAAA9F,GAAA6G,WAAAI,KAAAnB,EAAA9F,KAIA,IAAAqG,EAAA3G,OAAAqF,KAAA7D,KAAAqD,KAAA+B,OACAC,EAAA,GACA,IAAA,IAAAvG,EAAA,EAAAA,EAAAqG,EAAAxE,OAAA7B,IACA,CACA,IAAAwG,EAAAtF,KAAAqD,KAAA+B,MAAAD,EAAArG,IACAwG,EAAAhE,QAAAwD,kBAEAO,EAAAN,KAAAO,EAEA,CAEAD,EAAAL,MAAA,CAAAzE,EAAA0E,IAAA1E,EAAAe,QAAA4D,iBAAAD,EAAA3D,QAAA4D,mBACA,IAAA,IAAApG,EAAA,EAAAA,EAAAuG,EAAA1E,OAAA7B,IAEA8G,EAAAE,WAAAT,EAAAvG,GAAA6G,WAAAI,KAAAV,EAAAvG,KAGA8G,EAAAE,WAAA9F,KAAAwE,aAAAuB,KAAA/F,OACA4F,EAAAE,WAAA9F,KAAAoG,kBAAAL,KAAA/F,OAEA4F,EAAAS,MACAH,IAEAlG,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,4BAEAtC,KAAAwD,oBAAAxD,KAAAmB,MAAAY,IAAA2D,eACAM,EAAAE,KAEA,CAEAT,YAAAA,GAMA,OAJAzF,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,oBAEA,CACA,CACA8D,iBAAAA,CAAAhC,GAGA,OADApE,KAAAyF,eACArB,GACA,CAKAkC,kBAAAA,GAMA,OAJAtG,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,0BAEA,CACA,CACAiE,uBAAAA,CAAAnC,GAGA,OADApE,KAAAsG,qBACAlC,GACA,CAEAoC,YAAAA,GAMA,OAJAxG,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,oBAEA,CACA,CACAmE,iBAAAA,CAAArC,GAGA,OADApE,KAAAwG,eACApC,GACA,CAEAsC,UAAAA,GAOA,GALA1G,KAAAqD,KAAAsD,gBAEA3G,KAAA+B,IAAAmC,MAAA,iCAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,iBAGAtC,KAAAuD,oBAmEA,OADAvD,KAAA+B,IAAAkE,KAAA,YAAA1E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,4EACA,EAlEA,CACAtC,KAAAsG,qBACAtG,KAAAwG,eAGA,IAAA9B,EAAAlG,OAAAqF,KAAA7D,KAAAqD,KAAAsB,WACAiC,EAAA,GACA,IAAA,IAAA9H,EAAA,EAAAA,EAAA4F,EAAA/D,OAAA7B,IACA,CACA,IAAA+F,EAAA7E,KAAAqD,KAAAsB,UAAAD,EAAA5F,IACA+F,EAAAvD,QAAAiE,gBAEAqB,EAAA7B,KAAAF,EAEA,CAEA+B,EAAA5B,MAAA,CAAAzE,EAAA0E,IAAA1E,EAAAe,QAAAkE,sBAAAP,EAAA3D,QAAAkE,wBACA,IAAA,IAAA1G,EAAA,EAAAA,EAAA8H,EAAAjG,OAAA7B,IAEA8H,EAAA9H,GAAA4H,aAIA,IAAAvB,EAAA3G,OAAAqF,KAAA7D,KAAAqD,KAAA+B,OACAyB,EAAA,GACA,IAAA,IAAA/H,EAAA,EAAAA,EAAAqG,EAAAxE,OAAA7B,IACA,CACA,IAAAwG,EAAAtF,KAAAqD,KAAA+B,MAAAD,EAAArG,IACAwG,EAAAhE,QAAAiE,gBAEAsB,EAAA9B,KAAAO,EAEA,CAEAuB,EAAA7B,MAAA,CAAAzE,EAAA0E,IAAA1E,EAAAe,QAAAkE,sBAAAP,EAAA3D,QAAAkE,wBACA,IAAA,IAAA1G,EAAA,EAAAA,EAAA+H,EAAAlG,OAAA7B,IAEA+H,EAAA/H,GAAA4H,aAwBA,OArBA1G,KAAA8G,oBACA9G,KAAAsB,QAAAqB,2BAEA3C,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,0CAGAtC,KAAAyE,SAGAzE,KAAAsB,QAAAsB,4CAEA5C,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,4CAGAtC,KAAA+G,UAEA/G,KAAAuD,oBAAAvD,KAAAmB,MAAAY,IAAA2D,gBACA,CACA,CAMA,CACAsB,eAAAA,CAAA5C,GAEApE,KAAAqD,KAAAsD,gBAEA3G,KAAA+B,IAAAmC,MAAA,iCAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,sBAIA,IAAA0D,EAAA,mBAAA5B,GAAAA,EAcA,GAZA4B,IAEAhG,KAAA+B,IAAAkE,KAAA,YAAA1E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,gIACA0D,EAAAE,IAEAA,GAEAlG,KAAA+B,IAAAoE,MAAA,YAAA5E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,0CAAAf,OAAA2E,GAAAA,EACA,GAIAlG,KAAAuD,oBAsFA,OAFAvD,KAAA+B,IAAAkE,KAAA,YAAA1E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,iFAEA0D,IArFA,CACA,IAAAJ,EAAA5F,KAAAmB,MAAA0E,8CAAA,cAEA7F,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,iCAGAsD,EAAAE,WAAA9F,KAAAuG,wBAAAR,KAAA/F,OACA4F,EAAAE,WAAA9F,KAAAyG,kBAAAV,KAAA/F,OAGA,IAAA0E,EAAAlG,OAAAqF,KAAA7D,KAAAqD,KAAAsB,WACAiC,EAAA,GACA,IAAA,IAAA9H,EAAA,EAAAA,EAAA4F,EAAA/D,OAAA7B,IACA,CACA,IAAA+F,EAAA7E,KAAAqD,KAAAsB,UAAAD,EAAA5F,IACA+F,EAAAvD,QAAAiE,gBAEAqB,EAAA7B,KAAAF,EAEA,CAEA+B,EAAA5B,MAAA,CAAAzE,EAAA0E,IAAA1E,EAAAe,QAAAkE,sBAAAP,EAAA3D,QAAAkE,wBACA,IAAA,IAAA1G,EAAA,EAAAA,EAAA8H,EAAAjG,OAAA7B,IAEA8G,EAAAE,WAAAc,EAAA9H,GAAAkI,gBAAAjB,KAAAa,EAAA9H,KAKA,IAAAqG,EAAA3G,OAAAqF,KAAA7D,KAAAqD,KAAA+B,OACAyB,EAAA,GACA,IAAA,IAAA/H,EAAA,EAAAA,EAAAqG,EAAAxE,OAAA7B,IACA,CACA,IAAAwG,EAAAtF,KAAAqD,KAAA+B,MAAAD,EAAArG,IACAwG,EAAAhE,QAAAiE,gBAEAsB,EAAA9B,KAAAO,EAEA,CAGAuB,EAAA7B,MAAA,CAAAzE,EAAA0E,IAAA1E,EAAAe,QAAAkE,sBAAAP,EAAA3D,QAAAkE,wBACA,IAAA,IAAA1G,EAAA,EAAAA,EAAA+H,EAAAlG,OAAA7B,IACA,CACA,IAAAwG,EAAAuB,EAAA/H,GACA8G,EAAAE,WAAAR,EAAA0B,gBAAAjB,KAAAT,GACA,CAEAM,EAAAE,WAAA9F,KAAAiH,uBAAAlB,KAAA/F,OAEAA,KAAAsB,QAAAqB,2BAEA3C,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,2DAEAsD,EAAAE,WAAA9F,KAAA2F,WAAAI,KAAA/F,QAGAA,KAAAsB,QAAAsB,4CAEA5C,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,6DAEAsD,EAAAE,WAAA9F,KAAAkH,wBAAAnB,KAAA/F,QAGA4F,EAAAS,MACAH,IAEAlG,KAAAuD,oBAAAvD,KAAAmB,MAAAY,IAAA2D,eACA1F,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,8BAEA0D,MAEA,CAOA,CAEAc,iBAAAA,GAMA,OAJA9G,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,yBAEA,CACA,CACA2E,sBAAAA,CAAA7C,GAGA,OADApE,KAAA8G,oBACA1C,GACA,CAKA+C,wBAAAA,GAMA,OAJAnH,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,gCAEA,CACA,CACA8E,6BAAAA,CAAAhD,GAGA,OADApE,KAAAmH,2BACA/C,GACA,CAEAiD,kBAAAA,GAMA,OAJArH,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,0BAEA,CACA,CACAgF,uBAAAA,CAAAlD,GAGA,OADApE,KAAAqH,qBACAjD,GACA,CAEAmD,gBAAAA,GAEAvH,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,8CAEAtC,KAAAmH,2BAEA,IAAAhC,EAAA3G,OAAAqF,KAAA7D,KAAAqD,KAAA+B,OACAoC,EAAA,GACA,IAAA,IAAA1I,EAAA,EAAAA,EAAAqG,EAAAxE,OAAA7B,IACA,CACA,IAAAwG,EAAAtF,KAAAqD,KAAA+B,MAAAD,EAAArG,IACA0I,EAAAzC,KAAAO,EACA,CACA,IAAA,IAAAxG,EAAA,EAAAA,EAAA0I,EAAA7G,OAAA7B,IAEA0I,EAAA1I,GAAA2I,kBAKA,OAHAzH,KAAAqH,qBACArH,KAAA0H,0BACA1H,KAAAyD,8BAAAzD,KAAAmB,MAAAY,IAAA2D,gBACA,CACA,CACAiC,qBAAAA,CAAAvD,GAEA,IAAAwB,EAAA5F,KAAAmB,MAAA0E,8CAAA,cAGAG,EAAA,mBAAA5B,GAAAA,EAEA4B,IAEAhG,KAAA+B,IAAAkE,KAAA,YAAA1E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,sIACA0D,EAAAE,IAEAA,GAEAlG,KAAA+B,IAAAoE,MAAA,YAAA5E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,gDAAAf,OAAA2E,GAAAA,EACA,GAIAN,EAAAE,WAAA9F,KAAAoH,8BAAArB,KAAA/F,OAEA,IAAAmF,EAAA3G,OAAAqF,KAAA7D,KAAAqD,KAAA+B,OACAoC,EAAA,GACA,IAAA,IAAA1I,EAAA,EAAAA,EAAAqG,EAAAxE,OAAA7B,IACA,CACA,IAAAwG,EAAAtF,KAAAqD,KAAA+B,MAAAD,EAAArG,IACA0I,EAAAzC,KAAAO,EACA,CACA,IAAA,IAAAxG,EAAA,EAAAA,EAAA0I,EAAA7G,OAAA7B,IAEA8G,EAAAE,WAAA0B,EAAA1I,GAAA8I,qBAAA7B,KAAAyB,EAAA1I,KAEA8G,EAAAE,WAAA9F,KAAAsH,wBAAAvB,KAAA/F,OACA4F,EAAAE,WAAA9F,KAAA6H,6BAAA9B,KAAA/F,OAEA4F,EAAAS,MACAH,IAEAlG,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,uCAEAtC,KAAAyD,8BAAAzD,KAAAmB,MAAAY,IAAA2D,eACAM,EAAAE,KAEA,CAEAwB,uBAAAA,GAMA,OAJA1H,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,+BAEA,CACA,CACAuF,4BAAAA,CAAAzD,GAGA,OADApE,KAAA0H,0BACAtD,GACA,CAKA0D,sBAAAA,GAMA,OAJA9H,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,8BAEA,CACA,CACAyF,2BAAAA,CAAA3D,GAGA,OADApE,KAAA8H,yBACA1D,GACA,CAEA4D,gBAAAA,GAMA,OAJAhI,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,wBAEA,CACA,CACA2F,qBAAAA,CAAA7D,GAGA,OADApE,KAAAgI,mBACA5D,GACA,CAEA8D,cAAAA,GAEAlI,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,4CAEAtC,KAAA8H,yBAEA,IAAA3C,EAAA3G,OAAAqF,KAAA7D,KAAAqD,KAAA+B,OACA+C,EAAA,GACA,IAAA,IAAArJ,EAAA,EAAAA,EAAAqG,EAAAxE,OAAA7B,IACA,CACA,IAAAwG,EAAAtF,KAAAqD,KAAA+B,MAAAD,EAAArG,IACAqJ,EAAApD,KAAAO,EACA,CACA,IAAA,IAAAxG,EAAA,EAAAA,EAAAqJ,EAAAxH,OAAA7B,IAEAqJ,EAAArJ,GAAAsJ,gBAKA,OAHApI,KAAAgI,mBACAhI,KAAAqI,wBACArI,KAAA0D,4BAAA1D,KAAAmB,MAAAY,IAAA2D,gBACA,CACA,CACA4C,mBAAAA,CAAAlE,GAEA,IAAAwB,EAAA5F,KAAAmB,MAAA0E,8CAAA,cAGAG,EAAA,mBAAA5B,GAAAA,EAEA4B,IAEAhG,KAAA+B,IAAAkE,KAAA,YAAA1E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,oIACA0D,EAAAE,IAEAA,GAEAlG,KAAA+B,IAAAoE,MAAA,YAAA5E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,8CAAAf,OAAA2E,GAAAA,EACA,GAIAN,EAAAE,WAAA9F,KAAA+H,4BAAAhC,KAAA/F,OAEA,IAAAmF,EAAA3G,OAAAqF,KAAA7D,KAAAqD,KAAA+B,OACA+C,EAAA,GACA,IAAA,IAAArJ,EAAA,EAAAA,EAAAqG,EAAAxE,OAAA7B,IACA,CACA,IAAAwG,EAAAtF,KAAAqD,KAAA+B,MAAAD,EAAArG,IACAqJ,EAAApD,KAAAO,EACA,CACA,IAAA,IAAAxG,EAAA,EAAAA,EAAAqJ,EAAAxH,OAAA7B,IAEA8G,EAAAE,WAAAqC,EAAArJ,GAAAyJ,mBAAAxC,KAAAoC,EAAArJ,KAEA8G,EAAAE,WAAA9F,KAAAiI,sBAAAlC,KAAA/F,OACA4F,EAAAE,WAAA9F,KAAAwI,2BAAAzC,KAAA/F,OAEA4F,EAAAS,MACAH,IAEAlG,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,qCAEAtC,KAAA0D,4BAAA1D,KAAAmB,MAAAY,IAAA2D,eACAM,EAAAE,KAEA,CAEAmC,qBAAAA,GAMA,OAJArI,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,6BAEA,CACA,CACAkG,0BAAAA,CAAApE,GAGA,OADApE,KAAAqI,wBACAjE,GACA,CAKA2C,MAAAA,CAAA0B,EAAAC,EAAAC,EAAAC,GAEA,IAAAC,OAAA,IAAAJ,EAAAzI,KAAAsB,QAAAiB,2BAAAkG,EACAK,OAAA,IAAAJ,EAAA1I,KAAAsB,QAAAkB,2BAAAkG,EACAK,OAAA,IAAAJ,EAAA3I,KAAAsB,QAAAmB,+BAAAkG,EACAK,OAAA,IAAAJ,EAAA5I,KAAAsB,QAAAoB,+BAAAkG,EAEA5I,KAAAqD,KAAAsD,gBAEA3G,KAAA+B,IAAAmC,MAAA,iCAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,qBAAAf,OAAAuH,EAAA,kBAAAvH,OAAAwH,EAAA,0BAAAxH,OAAAyH,EAAA,cAIA,IAAA1D,EAAA,iBAAAuD,GAAA7I,KAAAkC,YAAA+G,SAAAJ,GACA,OAAAvD,EAMAA,EAAAyB,OAAA+B,EAAAC,EAAAC,IAJAhJ,KAAA+B,IAAAoE,MAAA,YAAA5E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,gCAAAf,OAAAsH,EAAA,sCACA,EAIA,CACAK,kBAAAA,GAOA,OALAlJ,KAAAqD,KAAAsD,gBAEA3G,KAAA+B,IAAAmC,MAAA,iCAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,yBAGAtC,KAAA+G,QACA,CAEAoC,WAAAA,CAAAV,EAAAC,EAAAC,EAAAC,EAAAxE,GAEA,IAAAyE,OAAA,IAAAJ,EAAAzI,KAAAsB,QAAAiB,2BAAAkG,EACAK,OAAA,IAAAJ,EAAA1I,KAAAsB,QAAAkB,2BAAAkG,EACAK,OAAA,IAAAJ,EAAA3I,KAAAsB,QAAAmB,+BAAAkG,EACAK,OAAA,IAAAJ,EAAA5I,KAAAsB,QAAAoB,+BAAAkG,EAGA5C,EAAA,mBAAA5B,EAAAA,EACA,mBAAAwE,EAAAA,EACA,mBAAAD,EAAAA,EACA,mBAAAD,EAAAA,EACA,mBAAAD,GAAAA,EAGAzC,IAEAhG,KAAA+B,IAAAkE,KAAA,YAAA1E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,4HACA0D,EAAAE,IAEAA,GAEAlG,KAAA+B,IAAAoE,MAAA,YAAA5E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,sCAAAf,OAAA2E,GAAAA,EACA,GAIAlG,KAAAqD,KAAAsD,gBAEA3G,KAAA+B,IAAAmC,MAAA,iCAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,qBAAAf,OAAAuH,EAAA,kBAAAvH,OAAAwH,EAAA,0BAAAxH,OAAAyH,EAAA,mBAGA,IAAA1D,EAAA,iBAAAuD,GAAA7I,KAAAkC,YAAA+G,SAAAJ,GACA,IAAAvD,EACA,CACA,IAAAzD,EAAA,YAAAN,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,+CAAAf,OAAAsH,EAAA,oCAKA,OAJA7I,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAoE,MAAAtE,GAEAmE,EAAA,IAAAxF,MAAAqB,GACA,CAEA,OAAAyD,EAAA6D,YAAAL,EAAAC,EAAAC,EAAAhD,EACA,CACAkB,uBAAAA,CAAA9C,GAOA,OALApE,KAAAqD,KAAAsD,gBAEA3G,KAAA+B,IAAAmC,MAAA,iCAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,8BAGAtC,KAAAmJ,YAAA/E,EACA,CAEAgF,eAAAA,GAEApJ,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,kCAGA,IAAA6C,EAAA3G,OAAAqF,KAAA7D,KAAAqD,KAAA+B,OAGAD,EAAAH,MAAA,CAAAzE,EAAA0E,IAEAjF,KAAAqD,KAAA+B,MAAA7E,GAAAe,QAAA+H,kBAAArJ,KAAAqD,KAAA+B,MAAAH,GAAA3D,QAAA+H,oBAEA,IAAA,IAAAvK,EAAA,EAAAA,EAAAqG,EAAAxE,OAAA7B,IACA,CACA,IAAAwG,EAAAtF,KAAAqD,KAAA+B,MAAAD,EAAArG,IACAwG,EAAAhE,QAAAgI,YAEAhE,EAAAyB,QAEA,CACA/G,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,mCAEA,CACAiH,oBAAAA,CAAAnF,GAEA,IAAAwB,EAAA5F,KAAAmB,MAAA0E,8CAAA,cAGAG,EAAA,mBAAA5B,EAAAA,EACA,mBAAAwE,qBAAAA,qBACA,mBAAAD,0BAAAA,0BACA,mBAAAD,gBAAAA,gBACA,mBAAAD,iBAAAA,gBAGAzC,IAEAhG,KAAA+B,IAAAkE,KAAA,YAAA1E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,qIACA0D,EAAAE,IAEAA,GAEAlG,KAAA+B,IAAAoE,MAAA,YAAA5E,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,+CAAAf,OAAA2E,GAAAA,EACA,GAIAlG,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,uCAKA,IAAA6C,EAAA3G,OAAAqF,KAAA7D,KAAAqD,KAAA+B,OAGAD,EAAAH,MAAA,CAAAzE,EAAA0E,IAEAjF,KAAAqD,KAAA+B,MAAA7E,GAAAe,QAAA+H,kBAAArJ,KAAAqD,KAAA+B,MAAAH,GAAA3D,QAAA+H,oBAEA,IAAA,IAAAvK,EAAA,EAAAA,EAAAqG,EAAAxE,OAAA7B,IACA,CACA,IAAAwG,EAAAtF,KAAAqD,KAAA+B,MAAAD,EAAArG,IACAwG,EAAAhE,QAAAgI,YAEA1D,EAAAE,WAAAR,EAAA6D,YAAApD,KAAAT,GAEA,CAEAM,EAAAS,MACAH,IAEAlG,KAAA2D,wBAAA3D,KAAAmB,MAAAY,IAAA2D,eACA1F,KAAAqD,KAAAY,aAAA,GAEAjE,KAAA+B,IAAAmC,MAAA,YAAA3C,OAAAvB,KAAAoB,KAAA,QAAAG,OAAAvB,KAAA4B,KAAA,MAAAL,OAAAvB,KAAAsB,QAAAgB,KAAA,oCAEA0D,EAAAE,KAEA,EH4FA,EAAE,CAAC,4BAA4B,KAAK,CAAC,EAAE,CAAC,GCr8BxC,CDq8B4C,EAC5C","file":"pict-application.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PictApplication = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;\n},{}],2:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase')\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport and other autorender views after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\t\tAutoRenderViewsAfterInitialize: false,\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\nclass PictApplication extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tthis.serviceType = 'PictApplication';\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\tthis.initializeTimestamp = false;\n\t\tthis.lastSolvedTimestamp = false;\n\t\tthis.lastMarshalFromViewsTimestamp = false;\n\t\tthis.lastMarshalToViewsTimestamp = false;\n\t\tthis.lastAutoRenderTimestamp = false;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\tonPreSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonPreSolveAsync(fCallback)\n\t{\n\t\tthis.onPreSolve();\n\t\treturn fCallback();\n\t}\n\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpProvidersToSolve[i].solve(tmpProvidersToSolve[i]);\n\t\t}\n\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvidersToSolve[i].solveAsync.bind(tmpProvidersToSolve[i]));\n\t\t}\n\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\n\t\t\t// Walk through any loaded providers and initialize them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpProvidersToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);\n\t\t}\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\n\t\t\t// Walk through any loaded providers and solve them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpProvidersToInitialize[i].initializeAsync.bind(tmpProvidersToInitialize[i]));\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn tmpCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] render:`);\n\t\t}\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\t}\n\trenderMainViewport()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`);\n\t\t}\n\n\t\treturn this.render();\n\t}\n\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] renderAsync:`);\n\t\t}\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn tmpCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\treturn tmpView.renderAsync(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, tmpCallback);\n\t}\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`);\n\t\t}\n\n\t\treturn this.renderAsync(fCallback);\n\t}\n\n\trenderAutoViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);\n\t\t}\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpView.render();\n\t\t\t}\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t}\n\t}\n\trenderAutoViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);\n\t\t}\n\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpView.renderAsync.bind(tmpView));\n\t\t\t}\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.lastAutoRenderTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t\t\t}\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n}\n\nmodule.exports = PictApplication;\n},{\"fable-serviceproviderbase\":1}]},{},[2])(2)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;","const libFableServiceBase = require('fable-serviceproviderbase')\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport and other autorender views after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\t\tAutoRenderViewsAfterInitialize: false,\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\nclass PictApplication extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tthis.serviceType = 'PictApplication';\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\tthis.initializeTimestamp = false;\n\t\tthis.lastSolvedTimestamp = false;\n\t\tthis.lastMarshalFromViewsTimestamp = false;\n\t\tthis.lastMarshalToViewsTimestamp = false;\n\t\tthis.lastAutoRenderTimestamp = false;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\tonPreSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonPreSolveAsync(fCallback)\n\t{\n\t\tthis.onPreSolve();\n\t\treturn fCallback();\n\t}\n\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpProvidersToSolve[i].solve(tmpProvidersToSolve[i]);\n\t\t}\n\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvidersToSolve[i].solveAsync.bind(tmpProvidersToSolve[i]));\n\t\t}\n\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\n\t\t\t// Walk through any loaded providers and initialize them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpProvidersToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);\n\t\t}\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\n\t\t\t// Walk through any loaded providers and solve them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpProvidersToInitialize[i].initializeAsync.bind(tmpProvidersToInitialize[i]));\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn tmpCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] render:`);\n\t\t}\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\t}\n\trenderMainViewport()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`);\n\t\t}\n\n\t\treturn this.render();\n\t}\n\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] renderAsync:`);\n\t\t}\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn tmpCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\treturn tmpView.renderAsync(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, tmpCallback);\n\t}\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`);\n\t\t}\n\n\t\treturn this.renderAsync(fCallback);\n\t}\n\n\trenderAutoViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);\n\t\t}\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpView.render();\n\t\t\t}\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t}\n\t}\n\trenderAutoViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);\n\t\t}\n\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpView.renderAsync.bind(tmpView));\n\t\t\t}\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.lastAutoRenderTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t\t\t}\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n}\n\nmodule.exports = PictApplication;"]}