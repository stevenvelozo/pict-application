{"version":3,"sources":["pict-application.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/package.json","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","package.json","source/Pict-Application.js"],"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","f","exports","module","define","amd","window","global","self","this","PictApplication","n","o","c","require","u","a","Error","code","p","length","name","version","description","main","scripts","start","test","tests","coverage","build","mocha","diff","extension","package","reporter","slow","timeout","ui","repository","type","url","keywords","author","license","bugs","homepage","devDependencies","fable","quackage","libPackage","FableServiceProviderBase","constructor","pFable","pOptions","pServiceHash","isFable","connectFable","_PackageFableServiceProvider","UUID","getUUID","options","Math","floor","random","serviceType","Hash","tmpErrorMessage","console","log","Logging","services","servicesMap","CoreServiceProviderBase","lint","types","eslint","pict","dependencies","libFableServiceBase","defaultPictSettings","Name","MainViewportViewIdentifier","MainViewportRenderableHash","MainViewportDestinationAddress","MainViewportDefaultDataAddress","AutoSolveAfterInitialize","AutoRenderMainViewportViewAfterInitialize","AutoRenderViewsAfterInitialize","AutoLoginAfterInitialize","AutoLoadDataAfterLogin","ConfigurationOnlyViews","Manifests","IdentifierAddressPrefix","tmpCarryOverConfiguration","settings","PictApplicationConfiguration","super","assign","JSON","parse","stringify","_Package","AppData","Bundle","initializeTimestamp","lastSolvedTimestamp","lastLoginTimestamp","lastMarshalFromViewsTimestamp","lastMarshalToViewsTimestamp","lastAutoRenderTimestamp","lastLoadDataTimestamp","tmpManifestKeys","keys","tmpManifestKey","instantiateServiceProvider","onPreSolve","LogNoisiness","trace","onPreSolveAsync","fCallback","onBeforeSolve","onBeforeSolveAsync","onSolve","onSolveAsync","solve","tmpLoadedProviders","providers","tmpProvidersToSolve","tmpProvider","AutoSolveWithApp","push","sort","b","AutoSolveOrdinal","tmpLoadedViews","views","tmpViewsToSolve","tmpView","AutoInitialize","AutoInitializeOrdinal","onAfterSolve","getTimeStamp","solveAsync","tmpAnticipate","instantiateServiceProviderWithoutRegistration","anticipate","bind","tmpCallback","warn","pError","error","onAfterSolveAsync","wait","onBeforeLoginAsync","onLoginAsync","loginAsync","onAfterLoginAsync","fNext","isLoggedIn","loadDataAsync","onBeforeLoadDataAsync","onLoadDataAsync","tmpProvidersToLoadData","AutoLoadDataWithApp","AutoLoadDataOrdinal","onAfterLoadDataAsync","onBeforeSaveDataAsync","onSaveDataAsync","saveDataAsync","tmpProvidersToSaveData","AutoSaveDataWithApp","AutoSaveDataOrdinal","onAfterSaveDataAsync","lastSaveDataTimestamp","onBeforeInitialize","onBeforeInitializeAsync","onInitialize","onInitializeAsync","initialize","LogControlFlow","tmpViewIdentifier","ViewIdentifier","info","addView","tmpProvidersToInitialize","tmpViewsToInitialize","onAfterInitialize","render","onCompletionOfInitialize","initializeAsync","onCompletionOfInitializeAsync","onAfterInitializeAsync","renderMainViewportAsync","message","stack","onBeforeMarshalFromViews","onBeforeMarshalFromViewsAsync","onMarshalFromViews","onMarshalFromViewsAsync","marshalFromViews","tmpViewsToMarshalFromViews","marshalFromView","onAfterMarshalFromViews","marshalFromViewsAsync","marshalFromViewAsync","onAfterMarshalFromViewsAsync","onBeforeMarshalToViews","onBeforeMarshalToViewsAsync","onMarshalToViews","onMarshalToViewsAsync","marshalToViews","tmpViewsToMarshalToViews","marshalToView","onAfterMarshalToViews","marshalToViewsAsync","marshalToViewAsync","onAfterMarshalToViewsAsync","onBeforeRender","onBeforeRenderAsync","pViewIdentifier","pRenderableHash","pRenderDestinationAddress","pTemplateDataAddress","tmpRenderableHash","tmpRenderDestinationAddress","tmpTemplateDataAddress","PictView","onRender","onAfterRender","onRenderAsync","renderAsync","tmpRenderAnticipate","newAnticipate","onAfterRenderAsync","renderMainViewport","renderAutoViews","AutoRenderOrdinal","AutoRender","renderAutoViewsAsync","isPictApplication"],"mappings":"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","file":"pict-application.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PictApplication = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\nmodule.exports={\n    \"name\": \"fable-serviceproviderbase\",\n    \"version\": \"3.0.15\",\n    \"description\": \"Simple base classes for fable services.\",\n    \"main\": \"source/Fable-ServiceProviderBase.js\",\n    \"scripts\": {\n        \"start\": \"node source/Fable-ServiceProviderBase.js\",\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase.git\"\n    },\n    \"keywords\": [\n        \"entity\",\n        \"behavior\"\n    ],\n    \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/fable-serviceproviderbase\",\n    \"devDependencies\": {\n        \"fable\": \"^3.0.143\",\n        \"quackage\": \"^1.0.33\"\n    }\n}\n},{}],2:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nconst libPackage = require('../package.json');\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// Initialize the services map if it wasn't passed in\n\t\t/** @type {Object} */\n\t\tthis._PackageFableServiceProvider = libPackage;\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;\n},{\"../package.json\":1}],3:[function(require,module,exports){\nmodule.exports={\n    \"name\": \"pict-application\",\n    \"version\": \"1.0.30\",\n    \"description\": \"Application base class for a pict view-based application\",\n    \"main\": \"source/Pict-Application.js\",\n    \"scripts\": {\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"start\": \"node source/Pict-Application.js\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\",\n        \"docker-dev-build\": \"docker build ./ -f Dockerfile_LUXURYCode -t pict-application-image:local\",\n        \"docker-dev-run\": \"docker run -it -d --name pict-application-dev -p 30001:8080 -p 38086:8086 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/pict-application\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" pict-application-image:local\",\n        \"docker-dev-shell\": \"docker exec -it pict-application-dev /bin/bash\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"lint\": \"eslint source/**\",\n        \"types\": \"tsc -p .\"\n    },\n    \"types\": \"types/source/Pict-Application.d.ts\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"git+https://github.com/stevenvelozo/pict-application.git\"\n    },\n    \"author\": \"steven velozo <steven@velozo.com>\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/pict-application/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/pict-application#readme\",\n    \"devDependencies\": {\n        \"@eslint/js\": \"^9.28.0\",\n        \"browser-env\": \"^3.3.0\",\n        \"eslint\": \"^9.28.0\",\n        \"pict\": \"^1.0.343\",\n        \"pict-provider\": \"^1.0.7\",\n        \"pict-view\": \"^1.0.64\",\n        \"quackage\": \"^1.0.45\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"dependencies\": {\n        \"fable-serviceproviderbase\": \"^3.0.15\"\n    }\n}\n\n},{}],4:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase')\n\nconst libPackage = require('../package.json');\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport and other autorender views after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\t\tAutoRenderViewsAfterInitialize: false,\n\t\tAutoLoginAfterInitialize: false,\n\t\tAutoLoadDataAfterLogin: false,\n\n\t\tConfigurationOnlyViews: [],\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\n/**\n * Base class for pict applications.\n */\nclass PictApplication extends libFableServiceBase\n{\n\t/**\n\t * @param {import('fable')} pFable\n\t * @param {Record<string, any>} [pOptions]\n\t * @param {string} [pServiceHash]\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpCarryOverConfiguration = (typeof(pFable.settings.PictApplicationConfiguration) === 'object') ? pFable.settings.PictApplicationConfiguration : {};\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), tmpCarryOverConfiguration, pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\n\t\t/** @type {any} */\n\t\tthis.options;\n\t\t/** @type {any} */\n\t\tthis.log;\n\t\t/** @type {import('pict') & import('fable')} */\n\t\tthis.fable;\n\t\t/** @type {string} */\n\t\tthis.UUID;\n\t\t/** @type {string} */\n\t\tthis.Hash;\n\t\t/**\n\t\t * @type {{ [key: string]: any }}\n\t\t */\n\t\tthis.servicesMap;\n\n\t\tthis.serviceType = 'PictApplication';\n\t\t/** @type {Record<string, any>} */\n\t\tthis._Package = libPackage;\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\t/** @type {Record<string, any>} */\n\t\tthis.AppData = this.fable.AppData;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.Bundle = this.fable.Bundle;\n\n\t\t/** @type {number} */\n\t\tthis.initializeTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastSolvedTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastLoginTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastMarshalFromViewsTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastMarshalToViewsTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastAutoRenderTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastLoadDataTimestamp;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonPreSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonPreSolveAsync(fCallback)\n\t{\n\t\tthis.onPreSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpProvidersToSolve[i].solve(tmpProvidersToSolve[i]);\n\t\t}\n\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvidersToSolve[i].solveAsync.bind(tmpProvidersToSolve[i]));\n\t\t}\n\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application Login                        */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tloginAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeLoginAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onLoginAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterLoginAsync.bind(this));\n\n\t\t// check and see if we should automatically trigger a data load\n\t\tif (this.options.AutoLoadDataAfterLogin)\n\t\t{\n\t\t\ttmpAnticipate.anticipate((fNext) =>\n\t\t\t{\n\t\t\t\tif (!this.isLoggedIn())\n\t\t\t\t{\n\t\t\t\t\treturn fNext();\n\t\t\t\t}\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto loading data after login...`);\n\t\t\t\t}\n\t\t\t\t//TODO: should data load errors funnel here? this creates a weird coupling between login and data load callbacks\n\t\t\t\tthis.loadDataAsync((pError) =>\n\t\t\t\t{\n\t\t\t\t\tfNext(pError);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastLoginTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Check if the application state is logged in. Defaults to true. Override this method in your application based on login requirements.\n\t *\n\t * @return {boolean}\n\t */\n\tisLoggedIn()\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application LoadData                     */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tloadDataAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeLoadDataAsync.bind(this));\n\n\t\t// Walk through any loaded providers and load their data as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToLoadData = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoLoadDataWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToLoadData.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToLoadData.sort((a, b) => { return a.options.AutoLoadDataOrdinal - b.options.AutoLoadDataOrdinal; });\n\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onBeforeLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onLoadDataAsync.bind(this));\n\n\t\t//TODO: think about ways to parallelize these\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onAfterLoadDataAsync.bind(this));\n\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onAfterLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t/** @param {Error} [pError] */\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastLoadDataTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application SaveData                     */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tsaveDataAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSaveDataAsync.bind(this));\n\n\t\t// Walk through any loaded providers and load their data as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSaveData = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSaveDataWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSaveData.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSaveData.sort((a, b) => { return a.options.AutoSaveDataOrdinal - b.options.AutoSaveDataOrdinal; });\n\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onBeforeSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSaveDataAsync.bind(this));\n\n\t\t//TODO: think about ways to parallelize these\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onAfterSaveDataAsync.bind(this));\n\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onAfterSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t/** @param {Error} [pError] */\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSaveDataTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}`\n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.onInitialize();\n\n\t\t\t// Walk through any loaded providers and initialize them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpProvidersToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\tthis.onCompletionOfInitialize();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);\n\t\t}\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}`\n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\n\t\t\t// Walk through any loaded providers and solve them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpProvidersToInitialize[i].initializeAsync.bind(tmpProvidersToInitialize[i]));\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoLoginAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto login (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.loginAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Error: ${pError.message || pError}`, { stack: pError.stack });\n\t\t\t\t\t}\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn this.onCompletionOfInitializeAsync(tmpCallback);\n\t\t}\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonCompletionOfInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onCompletionOfInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonCompletionOfInitializeAsync(fCallback)\n\t{\n\t\tthis.onCompletionOfInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\tthis.onBeforeRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {string} [pViewIdentifier] - The hash of the view to render. By default, the main viewport view is rendered.\n\t * @param {string} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string} [pTemplateDataAddress] - The address where the data for the template is stored.\n\t *\n\t * TODO: Should we support objects for pTemplateDataAddress for parity with pict-view?\n\t */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] render:`);\n\t\t}\n\n\t\tthis.onBeforeRender();\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.onRender();\n\n\t\ttmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\n\t\tthis.onAfterRender();\n\n\t\treturn true;\n\t}\n\t/**\n\t * @return {boolean}\n\t */\n\tonRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonRenderAsync(fCallback)\n\t{\n\t\tthis.onRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {string|((error?: Error) => void)} pViewIdentifier - The hash of the view to render. By default, the main viewport view is rendered. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pRenderableHash] - The hash of the renderable to render. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pRenderDestinationAddress] - The address where the renderable will be rendered. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pTemplateDataAddress] - The address where the data for the template is stored. (or the callback)\n\t * @param {(error?: Error) => void} [fCallback] - The callback, if all other parameters are provided.\n\t *\n\t * TODO: Should we support objects for pTemplateDataAddress for parity with pict-view?\n\t */\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] renderAsync:`);\n\t\t}\n\n\t\tlet tmpRenderAnticipate = this.fable.newAnticipate();\n\n\t\ttmpRenderAnticipate.anticipate(this.onBeforeRenderAsync.bind(this));\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn tmpCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\ttmpRenderAnticipate.anticipate(this.onRenderAsync.bind(this));\n\n\t\ttmpRenderAnticipate.anticipate(\n\t\t\t(fNext) =>\n\t\t\t{\n\t\t\t\ttmpView.renderAsync.call(tmpView, tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, fNext);\n\t\t\t});\n\n\t\ttmpRenderAnticipate.anticipate(this.onAfterRenderAsync.bind(this));\n\n\t\treturn tmpRenderAnticipate.wait(tmpCallback);\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\tthis.onAfterRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\trenderMainViewport()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`);\n\t\t}\n\n\t\treturn this.render();\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`);\n\t\t}\n\n\t\treturn this.renderAsync(fCallback);\n\t}\n\t/**\n\t * @return {void}\n\t */\n\trenderAutoViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);\n\t\t}\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) =>\n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpView.render();\n\t\t\t}\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t}\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\trenderAutoViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);\n\t\t}\n\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) =>\n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpView.renderAsync.bind(tmpView));\n\t\t\t}\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.lastAutoRenderTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t\t\t}\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tget isPictApplication()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictApplication;\n\n},{\"../package.json\":3,\"fable-serviceproviderbase\":2}]},{},[4])(4)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports={\n    \"name\": \"fable-serviceproviderbase\",\n    \"version\": \"3.0.15\",\n    \"description\": \"Simple base classes for fable services.\",\n    \"main\": \"source/Fable-ServiceProviderBase.js\",\n    \"scripts\": {\n        \"start\": \"node source/Fable-ServiceProviderBase.js\",\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase.git\"\n    },\n    \"keywords\": [\n        \"entity\",\n        \"behavior\"\n    ],\n    \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/fable-serviceproviderbase\",\n    \"devDependencies\": {\n        \"fable\": \"^3.0.143\",\n        \"quackage\": \"^1.0.33\"\n    }\n}","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nconst libPackage = require('../package.json');\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// Initialize the services map if it wasn't passed in\n\t\t/** @type {Object} */\n\t\tthis._PackageFableServiceProvider = libPackage;\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;","module.exports={\n    \"name\": \"pict-application\",\n    \"version\": \"1.0.30\",\n    \"description\": \"Application base class for a pict view-based application\",\n    \"main\": \"source/Pict-Application.js\",\n    \"scripts\": {\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"start\": \"node source/Pict-Application.js\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\",\n        \"docker-dev-build\": \"docker build ./ -f Dockerfile_LUXURYCode -t pict-application-image:local\",\n        \"docker-dev-run\": \"docker run -it -d --name pict-application-dev -p 30001:8080 -p 38086:8086 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/pict-application\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" pict-application-image:local\",\n        \"docker-dev-shell\": \"docker exec -it pict-application-dev /bin/bash\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"lint\": \"eslint source/**\",\n        \"types\": \"tsc -p .\"\n    },\n    \"types\": \"types/source/Pict-Application.d.ts\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"git+https://github.com/stevenvelozo/pict-application.git\"\n    },\n    \"author\": \"steven velozo <steven@velozo.com>\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/pict-application/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/pict-application#readme\",\n    \"devDependencies\": {\n        \"@eslint/js\": \"^9.28.0\",\n        \"browser-env\": \"^3.3.0\",\n        \"eslint\": \"^9.28.0\",\n        \"pict\": \"^1.0.343\",\n        \"pict-provider\": \"^1.0.7\",\n        \"pict-view\": \"^1.0.64\",\n        \"quackage\": \"^1.0.45\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"dependencies\": {\n        \"fable-serviceproviderbase\": \"^3.0.15\"\n    }\n}\n","const libFableServiceBase = require('fable-serviceproviderbase')\n\nconst libPackage = require('../package.json');\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport and other autorender views after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\t\tAutoRenderViewsAfterInitialize: false,\n\t\tAutoLoginAfterInitialize: false,\n\t\tAutoLoadDataAfterLogin: false,\n\n\t\tConfigurationOnlyViews: [],\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\n/**\n * Base class for pict applications.\n */\nclass PictApplication extends libFableServiceBase\n{\n\t/**\n\t * @param {import('fable')} pFable\n\t * @param {Record<string, any>} [pOptions]\n\t * @param {string} [pServiceHash]\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpCarryOverConfiguration = (typeof(pFable.settings.PictApplicationConfiguration) === 'object') ? pFable.settings.PictApplicationConfiguration : {};\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), tmpCarryOverConfiguration, pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\n\t\t/** @type {any} */\n\t\tthis.options;\n\t\t/** @type {any} */\n\t\tthis.log;\n\t\t/** @type {import('pict') & import('fable')} */\n\t\tthis.fable;\n\t\t/** @type {string} */\n\t\tthis.UUID;\n\t\t/** @type {string} */\n\t\tthis.Hash;\n\t\t/**\n\t\t * @type {{ [key: string]: any }}\n\t\t */\n\t\tthis.servicesMap;\n\n\t\tthis.serviceType = 'PictApplication';\n\t\t/** @type {Record<string, any>} */\n\t\tthis._Package = libPackage;\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\t/** @type {Record<string, any>} */\n\t\tthis.AppData = this.fable.AppData;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.Bundle = this.fable.Bundle;\n\n\t\t/** @type {number} */\n\t\tthis.initializeTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastSolvedTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastLoginTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastMarshalFromViewsTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastMarshalToViewsTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastAutoRenderTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastLoadDataTimestamp;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonPreSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonPreSolveAsync(fCallback)\n\t{\n\t\tthis.onPreSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpProvidersToSolve[i].solve(tmpProvidersToSolve[i]);\n\t\t}\n\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvidersToSolve[i].solveAsync.bind(tmpProvidersToSolve[i]));\n\t\t}\n\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application Login                        */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tloginAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeLoginAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onLoginAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterLoginAsync.bind(this));\n\n\t\t// check and see if we should automatically trigger a data load\n\t\tif (this.options.AutoLoadDataAfterLogin)\n\t\t{\n\t\t\ttmpAnticipate.anticipate((fNext) =>\n\t\t\t{\n\t\t\t\tif (!this.isLoggedIn())\n\t\t\t\t{\n\t\t\t\t\treturn fNext();\n\t\t\t\t}\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto loading data after login...`);\n\t\t\t\t}\n\t\t\t\t//TODO: should data load errors funnel here? this creates a weird coupling between login and data load callbacks\n\t\t\t\tthis.loadDataAsync((pError) =>\n\t\t\t\t{\n\t\t\t\t\tfNext(pError);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastLoginTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Check if the application state is logged in. Defaults to true. Override this method in your application based on login requirements.\n\t *\n\t * @return {boolean}\n\t */\n\tisLoggedIn()\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application LoadData                     */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tloadDataAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeLoadDataAsync.bind(this));\n\n\t\t// Walk through any loaded providers and load their data as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToLoadData = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoLoadDataWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToLoadData.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToLoadData.sort((a, b) => { return a.options.AutoLoadDataOrdinal - b.options.AutoLoadDataOrdinal; });\n\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onBeforeLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onLoadDataAsync.bind(this));\n\n\t\t//TODO: think about ways to parallelize these\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onAfterLoadDataAsync.bind(this));\n\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onAfterLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t/** @param {Error} [pError] */\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastLoadDataTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application SaveData                     */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tsaveDataAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSaveDataAsync.bind(this));\n\n\t\t// Walk through any loaded providers and load their data as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSaveData = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSaveDataWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSaveData.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSaveData.sort((a, b) => { return a.options.AutoSaveDataOrdinal - b.options.AutoSaveDataOrdinal; });\n\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onBeforeSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSaveDataAsync.bind(this));\n\n\t\t//TODO: think about ways to parallelize these\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onAfterSaveDataAsync.bind(this));\n\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onAfterSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t/** @param {Error} [pError] */\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSaveDataTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}`\n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.onInitialize();\n\n\t\t\t// Walk through any loaded providers and initialize them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpProvidersToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\tthis.onCompletionOfInitialize();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);\n\t\t}\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}`\n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\n\t\t\t// Walk through any loaded providers and solve them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpProvidersToInitialize[i].initializeAsync.bind(tmpProvidersToInitialize[i]));\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoLoginAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto login (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.loginAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Error: ${pError.message || pError}`, { stack: pError.stack });\n\t\t\t\t\t}\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn this.onCompletionOfInitializeAsync(tmpCallback);\n\t\t}\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonCompletionOfInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onCompletionOfInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonCompletionOfInitializeAsync(fCallback)\n\t{\n\t\tthis.onCompletionOfInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\tthis.onBeforeRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {string} [pViewIdentifier] - The hash of the view to render. By default, the main viewport view is rendered.\n\t * @param {string} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string} [pTemplateDataAddress] - The address where the data for the template is stored.\n\t *\n\t * TODO: Should we support objects for pTemplateDataAddress for parity with pict-view?\n\t */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] render:`);\n\t\t}\n\n\t\tthis.onBeforeRender();\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.onRender();\n\n\t\ttmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\n\t\tthis.onAfterRender();\n\n\t\treturn true;\n\t}\n\t/**\n\t * @return {boolean}\n\t */\n\tonRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonRenderAsync(fCallback)\n\t{\n\t\tthis.onRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {string|((error?: Error) => void)} pViewIdentifier - The hash of the view to render. By default, the main viewport view is rendered. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pRenderableHash] - The hash of the renderable to render. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pRenderDestinationAddress] - The address where the renderable will be rendered. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pTemplateDataAddress] - The address where the data for the template is stored. (or the callback)\n\t * @param {(error?: Error) => void} [fCallback] - The callback, if all other parameters are provided.\n\t *\n\t * TODO: Should we support objects for pTemplateDataAddress for parity with pict-view?\n\t */\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] renderAsync:`);\n\t\t}\n\n\t\tlet tmpRenderAnticipate = this.fable.newAnticipate();\n\n\t\ttmpRenderAnticipate.anticipate(this.onBeforeRenderAsync.bind(this));\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn tmpCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\ttmpRenderAnticipate.anticipate(this.onRenderAsync.bind(this));\n\n\t\ttmpRenderAnticipate.anticipate(\n\t\t\t(fNext) =>\n\t\t\t{\n\t\t\t\ttmpView.renderAsync.call(tmpView, tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, fNext);\n\t\t\t});\n\n\t\ttmpRenderAnticipate.anticipate(this.onAfterRenderAsync.bind(this));\n\n\t\treturn tmpRenderAnticipate.wait(tmpCallback);\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\tthis.onAfterRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\trenderMainViewport()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`);\n\t\t}\n\n\t\treturn this.render();\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`);\n\t\t}\n\n\t\treturn this.renderAsync(fCallback);\n\t}\n\t/**\n\t * @return {void}\n\t */\n\trenderAutoViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);\n\t\t}\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) =>\n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpView.render();\n\t\t\t}\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t}\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\trenderAutoViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);\n\t\t}\n\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) =>\n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpView.renderAsync.bind(tmpView));\n\t\t\t}\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.lastAutoRenderTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t\t\t}\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tget isPictApplication()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictApplication;\n"]}