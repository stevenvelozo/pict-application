{"version":3,"sources":["pict-application.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase-Preinit.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","source/Pict-Application.js"],"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","f","exports","module","define","amd","window","global","self","this","PictApplication","r","e","n","t","o","i","c","require","u","a","Error","code","p","length","FableCoreServiceProviderBase","constructor","pOptions","pServiceHash","fable","options","serviceType","UUID","concat","Math","floor","random","Hash","connectFable","pFable","FableServiceProviderBase","isFable","getUUID","log","servicesMap","services","CoreServiceProviderBase","libFableServiceBase","defaultPictSettings","Name","MainViewportViewIdentifier","MainViewportRenderableHash","MainViewportDestinationAddress","MainViewportDefaultDataAddress","AutoSolveAfterInitialize","AutoRenderMainViewportViewAfterInitialize","Manifests","IdentifierAddressPrefix","super","assign","JSON","parse","stringify","pict","AppData","initializeTimestamp","lastSolvedTimestamp","lastMarshalFromViewsTimestamp","lastMarshalToViewsTimestamp","tmpManifestKeys","keys","tmpManifestKey","serviceManager","instantiateServiceProvider","onBeforeSolve","LogNoisiness","trace","onBeforeSolveAsync","fCallback","onSolve","onSolveAsync","solve","tmpLoadedViews","views","tmpViewsToSolve","tmpView","AutoInitialize","push","sort","b","AutoInitializeOrdinal","onAfterSolve","getTimeStamp","solveAsync","tmpAnticipate","instantiateServiceProviderWithoutRegistration","anticipate","bind","AutoSolveWithApp","AutoSolveOrdinal","onAfterSolveAsync","wait","pError","onBeforeInitialize","onBeforeInitializeAsync","onInitialize","onInitializeAsync","initialize","warn","tmpViewsToInitialize","onAfterInitialize","render","initializeAsync","fCallBack","onAfterInitializeAsync","renderMainViewportAsync","onBeforeMarshalFromViews","onBeforeMarshalFromViewsAsync","onMarshalFromViews","onMarshalFromViewsAsync","marshalFromViews","tmpViewsToMarshalFromViews","marshalFromView","onAfterMarshalFromViews","marshalFromViewsAsync","marshalFromViewAsync","onAfterMarshalFromViewsAsync","onBeforeMarshalToViews","onBeforeMarshalToViewsAsync","onMarshalToViews","onMarshalToViewsAsync","marshalToViews","tmpViewsToMarshalToViews","marshalToView","onAfterMarshalToViews","marshalToViewsAsync","marshalToViewAsync","onAfterMarshalToViewsAsync","pViewIdentifier","pRenderableHash","pRenderDestinationAddress","pTemplateDataAddress","tmpViewIdentifier","tmpRenderableHash","tmpRenderDestinationAddress","tmpTemplateDataAddress","PictView","error","renderMainViewport","renderAsync","tmpErrorMessage"],"mappings":"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","file":"pict-application.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PictApplication = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n\n},{}],2:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.servicesMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');\n},{\"./Fable-ServiceProviderBase-Preinit.js\":1}],3:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase')\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\nclass PictApplication extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tthis.serviceType = 'PictApplication';\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\tthis.initializeTimestamp = false;\n\t\tthis.lastSolvedTimestamp = false;\n\t\tthis.lastMarshalFromViewsTimestamp = false;\n\t\tthis.lastMarshalToViewsTimestamp = false;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.serviceManager.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\tinitializeAsync(fCallBack)\n\t{\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn fCallBack();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\t}\n\trenderMainViewport()\n\t{\n\t\treturn this.render(this.options.MainViewportViewIdentifier, this.options.MainViewportRenderableHash, this.options.MainViewportDestinationAddress, this.options.MainViewportDefaultDataAddress);\n\t}\n\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn fCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\treturn tmpView.renderAsync(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, fCallback);\n\t}\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\treturn this.renderAsync(this.options.MainViewportViewIdentifier, this.options.MainViewportRenderableHash, this.options.MainViewportDestinationAddress, this.options.MainViewportDefaultDataAddress, fCallback);\n\t}\n}\n\nmodule.exports = PictApplication;\n},{\"fable-serviceproviderbase\":2}]},{},[3])(3)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.servicesMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');","const libFableServiceBase = require('fable-serviceproviderbase')\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\nclass PictApplication extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tthis.serviceType = 'PictApplication';\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\tthis.initializeTimestamp = false;\n\t\tthis.lastSolvedTimestamp = false;\n\t\tthis.lastMarshalFromViewsTimestamp = false;\n\t\tthis.lastMarshalToViewsTimestamp = false;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.serviceManager.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\tinitializeAsync(fCallBack)\n\t{\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn fCallBack();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\t}\n\trenderMainViewport()\n\t{\n\t\treturn this.render(this.options.MainViewportViewIdentifier, this.options.MainViewportRenderableHash, this.options.MainViewportDestinationAddress, this.options.MainViewportDefaultDataAddress);\n\t}\n\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn fCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\treturn tmpView.renderAsync(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, fCallback);\n\t}\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\treturn this.renderAsync(this.options.MainViewportViewIdentifier, this.options.MainViewportRenderableHash, this.options.MainViewportDestinationAddress, this.options.MainViewportDefaultDataAddress, fCallback);\n\t}\n}\n\nmodule.exports = PictApplication;"]}