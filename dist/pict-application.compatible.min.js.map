{"version":3,"sources":["pict-application.compatible.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase-Preinit.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","source/Pict-Application.js"],"names":["_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","writable","configurable","defineProperty","_setPrototypeOf","o","p","setPrototypeOf","bind","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","result","Super","_getPrototypeOf","NewTarget","this","Reflect","construct","arguments","apply","_possibleConstructorReturn","self","call","_typeof","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","_classCallCheck","instance","Constructor","_defineProperties","target","props","i","length","descriptor","enumerable","_toPropertyKey","key","_createClass","protoProps","staticProps","_defineProperty","obj","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","Number","iterator","f","exports","module","define","amd","window","global","PictApplication","r","n","t","c","require","u","a","Error","code","FableCoreServiceProviderBase","pOptions","pServiceHash","fable","options","serviceType","UUID","concat","Math","floor","random","Hash","pFable","FableServiceProviderBase","isFable","getUUID","log","servicesMap","services","CoreServiceProviderBase","libFableServiceBase","defaultPictSettings","Name","MainViewportViewIdentifier","MainViewportRenderableHash","MainViewportDestinationAddress","MainViewportDefaultDataAddress","AutoSolveAfterInitialize","AutoRenderMainViewportViewAfterInitialize","Manifests","IdentifierAddressPrefix","_libFableServiceBase","_super","_this","tmpOptions","assign","JSON","parse","stringify","pict","AppData","initializeTimestamp","lastSolvedTimestamp","lastMarshalFromViewsTimestamp","lastMarshalToViewsTimestamp","tmpManifestKeys","keys","tmpManifestKey","serviceManager","instantiateServiceProvider","LogNoisiness","trace","fCallback","onBeforeSolve","onSolve","tmpLoadedViews","views","tmpViewsToSolve","tmpView","AutoInitialize","push","sort","b","AutoInitializeOrdinal","solve","onAfterSolve","getTimeStamp","_this2","tmpAnticipate","instantiateServiceProviderWithoutRegistration","anticipate","onBeforeSolveAsync","AutoSolveWithApp","AutoSolveOrdinal","solveAsync","onSolveAsync","onAfterSolveAsync","wait","pError","onBeforeInitialize","onInitialize","warn","tmpViewsToInitialize","initialize","onAfterInitialize","render","fCallBack","_this3","onBeforeInitializeAsync","onInitializeAsync","initializeAsync","onAfterInitializeAsync","renderMainViewportAsync","onBeforeMarshalFromViews","onMarshalFromViews","tmpViewsToMarshalFromViews","marshalFromView","onAfterMarshalFromViews","_this4","onBeforeMarshalFromViewsAsync","marshalFromViewAsync","onMarshalFromViewsAsync","onAfterMarshalFromViewsAsync","onBeforeMarshalToViews","onMarshalToViews","tmpViewsToMarshalToViews","marshalToView","onAfterMarshalToViews","_this5","onBeforeMarshalToViewsAsync","marshalToViewAsync","onMarshalToViewsAsync","onAfterMarshalToViewsAsync","pViewIdentifier","pRenderableHash","pRenderDestinationAddress","pTemplateDataAddress","tmpViewIdentifier","tmpRenderableHash","tmpRenderDestinationAddress","tmpTemplateDataAddress","PictView","error","tmpErrorMessage","renderAsync"],"mappings":"AAAA,aAEA,SAASA,UAAUC,EAAUC,GAAc,GAA0B,mBAAfA,GAA4C,OAAfA,EAAuB,MAAM,IAAIC,UAAU,sDAAyDF,EAASG,UAAYC,OAAOC,OAAOJ,GAAcA,EAAWE,UAAW,CAAEG,YAAa,CAAEC,MAAOP,EAAUQ,UAAU,EAAMC,cAAc,KAAWL,OAAOM,eAAeV,EAAU,YAAa,CAAEQ,UAAU,IAAcP,GAAYU,gBAAgBX,EAAUC,EAAa,CACnc,SAASU,gBAAgBC,EAAGC,GAA6I,OAAxIF,gBAAkBP,OAAOU,eAAiBV,OAAOU,eAAeC,OAAS,SAAyBH,EAAGC,GAAsB,OAAjBD,EAAEI,UAAYH,EAAUD,CAAG,EAAUD,gBAAgBC,EAAGC,EAAI,CACvM,SAASI,aAAaC,GAAW,IAAIC,EAA4BC,4BAA6B,OAAO,WAAkC,IAAsCC,EAAlCC,EAAQC,gBAAgBL,GAAkB,GAAIC,EAA2B,CAAE,IAAIK,EAAYD,gBAAgBE,MAAMnB,YAAae,EAASK,QAAQC,UAAUL,EAAOM,UAAWJ,EAAY,MAASH,EAASC,EAAMO,MAAMJ,KAAMG,WAAc,OAAOE,2BAA2BL,KAAMJ,EAAS,CAAG,CACxa,SAASS,2BAA2BC,EAAMC,GAAQ,GAAIA,IAA2B,WAAlBC,QAAQD,IAAsC,mBAATA,GAAwB,OAAOA,EAAa,QAAa,IAATA,EAAmB,MAAM,IAAI9B,UAAU,4DAA+D,OAAOgC,uBAAuBH,EAAO,CAC/R,SAASG,uBAAuBH,GAAQ,QAAa,IAATA,EAAmB,MAAM,IAAII,eAAe,6DAAgE,OAAOJ,CAAM,CACrK,SAASX,4BAA8B,GAAuB,oBAAZM,UAA4BA,QAAQC,UAAW,OAAO,EAAO,GAAID,QAAQC,UAAUS,KAAM,OAAO,EAAO,GAAqB,mBAAVC,MAAsB,OAAO,EAAM,IAAsF,OAAhFC,QAAQnC,UAAUoC,QAAQP,KAAKN,QAAQC,UAAUW,QAAS,IAAI,WAAa,MAAY,CAAM,CAAE,MAAOE,GAAK,OAAO,CAAO,CAAE,CACxU,SAASjB,gBAAgBX,GAA+J,OAA1JW,gBAAkBnB,OAAOU,eAAiBV,OAAOqC,eAAe1B,OAAS,SAAyBH,GAAK,OAAOA,EAAEI,WAAaZ,OAAOqC,eAAe7B,EAAI,EAAUW,gBAAgBX,EAAI,CACnN,SAAS8B,gBAAgBC,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAI1C,UAAU,oCAAwC,CACxJ,SAAS2C,kBAAkBC,EAAQC,GAAS,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,IAAIE,EAAaH,EAAMC,GAAIE,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWzC,cAAe,EAAU,UAAWyC,IAAYA,EAAW1C,UAAW,GAAMJ,OAAOM,eAAeoC,EAAQM,eAAeF,EAAWG,KAAMH,EAAa,CAAE,CAC5U,SAASI,aAAaV,EAAaW,EAAYC,GAAyN,OAAtMD,GAAYV,kBAAkBD,EAAYzC,UAAWoD,GAAiBC,GAAaX,kBAAkBD,EAAaY,GAAcpD,OAAOM,eAAekC,EAAa,YAAa,CAAEpC,UAAU,IAAiBoC,CAAa,CAC5R,SAASa,gBAAgBC,EAAKL,EAAK9C,GAA4L,OAAnL8C,EAAMD,eAAeC,MAAiBK,EAAOtD,OAAOM,eAAegD,EAAKL,EAAK,CAAE9C,MAAOA,EAAO4C,YAAY,EAAM1C,cAAc,EAAMD,UAAU,IAAkBkD,EAAIL,GAAO9C,EAAgBmD,CAAK,CAC3O,SAASN,eAAeO,GAAO,IAAIN,EAAMO,aAAaD,EAAK,UAAW,MAAwB,WAAjB1B,QAAQoB,GAAoBA,EAAMQ,OAAOR,EAAM,CAC5H,SAASO,aAAaE,EAAOC,GAAQ,GAAuB,WAAnB9B,QAAQ6B,IAAiC,OAAVA,EAAgB,OAAOA,EAAO,IAAIE,EAAOF,EAAMG,OAAOC,aAAc,QAAaC,IAATH,EAAoB,CAAE,IAAII,EAAMJ,EAAKhC,KAAK8B,EAAOC,GAAQ,WAAY,GAAqB,WAAjB9B,QAAQmC,GAAmB,OAAOA,EAAK,MAAM,IAAIlE,UAAU,+CAAiD,CAAE,OAAiB,WAAT6D,EAAoBF,OAASQ,QAAQP,EAAQ,CAC5X,SAAS7B,QAAQrB,GAAgC,OAAOqB,QAAU,mBAAqBgC,QAAU,iBAAmBA,OAAOK,SAAW,SAAU1D,GAAK,cAAcA,CAAG,EAAI,SAAUA,GAAK,OAAOA,GAAK,mBAAqBqD,QAAUrD,EAAEN,cAAgB2D,QAAUrD,IAAMqD,OAAO9D,UAAY,gBAAkBS,CAAG,EAAGqB,QAAQrB,EAAI,ECf7T,SAAA2D,GAAA,GAAA,YAAA,oBAAAC,QAAA,YAAAvC,QAAAuC,WAAA,oBAAAC,OAAAA,OAAAD,QAAAD,SAAA,GAAA,mBAAAG,QAAAA,OAAAC,IAAAD,OAAA,GAAAH,OAAA,EAAA,oBAAAK,OAAAA,OAAA,oBAAAC,OAAAA,OAAA,oBAAA9C,KAAAA,KAAAN,MAAAqD,gBAAAP,GAAA,CAAA,CAAA,EAAA,WAAA,OAAA,SAAAQ,EAAAvC,EAAAwC,EAAAC,GAAA,SAAArE,EAAAoC,EAAAuB,GAAA,IAAAS,EAAAhC,GAAA,CAAA,IAAAR,EAAAQ,GAAA,CAAA,IAAAkC,EAAA,mBAAAC,SAAAA,QAAA,IAAAZ,GAAAW,EAAA,OAAAA,EAAAlC,GAAA,GAAA,GAAAoC,EAAA,OAAAA,EAAApC,GAAA,GAAA,IAAAqC,EAAA,IAAAC,MAAA,uBAAAtC,EAAA,KAAA,MAAAqC,EAAAE,KAAA,mBAAAF,CAAA,CAAA,IAAAxE,EAAAmE,EAAAhC,GAAA,CAAAwB,QAAA,CAAA,GAAAhC,EAAAQ,GAAA,GAAAhB,KAAAnB,EAAA2D,SAAA,SAAAO,GAAA,OAAAnE,EAAA4B,EAAAQ,GAAA,GAAA+B,IAAAA,EAAA,GAAAlE,EAAAA,EAAA2D,QAAAO,EAAAvC,EAAAwC,EAAAC,EAAA,CAAA,OAAAD,EAAAhC,GAAAwB,OAAA,CAAA,IAAA,IAAAY,EAAA,mBAAAD,SAAAA,QAAAnC,EAAA,EAAAA,EAAAiC,EAAAhC,OAAAD,IAAApC,EAAAqE,EAAAjC,IAAA,OAAApC,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAAuE,EAAAV,EAAAD,GCAA,IASAgB,EAAA,WAEA,SAAAA,EAAAC,EAAAC,GACAhD,gBAAAjB,KAAA+D,GACA/D,KAAAkE,OAAA,EAEAlE,KAAAmE,QAAA,WAAA3D,QAAAwD,GAAAA,EAAA,CAAA,EAEAhE,KAAAoE,YAAA,UAGApE,KAAAqE,KAAA,WAAAC,OAAAC,KAAAC,MAAA,MAAAD,KAAAE,SAAA,MAEAzE,KAAA0E,KAAA,iBAAAT,EAAAA,EAAA,GAAAK,OAAAtE,KAAAqE,KACA,CAWA,OAXAxC,aAAAkC,EAAA,CAAA,CAAAnC,IAAA,eAAA9C,MAMA,SAAA6F,GAIA,OAFA3E,KAAAkE,MAAAS,GAEA,CACA,KAAAZ,CAAA,CAzBA,GAyBA/B,gBAzBA+B,EAAA,kBAiBA,GAWAf,EAAAD,QAAAgB,CFGA,EAAE,CAAC,GAAG,EAAE,CAAC,SAASL,EAAQV,EAAOD,GGxCjC,IAKA6B,EAAA/C,cAEA,SAAA+C,EAAAD,EAAAX,EAAAC,GACAhD,gBAAAjB,KAAA4E,GACA5E,KAAAkE,MAAAS,EAEA3E,KAAAmE,QAAA,WAAA3D,QAAAwD,GAAAA,EACA,WAAAxD,QAAAmE,IAAAA,EAAAE,QACA,CAAA,EADAF,EAGA3E,KAAAoE,YAAA,UAEA,mBAAAO,EAAAG,QAEA9E,KAAAqE,KAAAM,EAAAG,UAIA9E,KAAAqE,KAAA,cAAAC,OAAAC,KAAAC,MAAA,MAAAD,KAAAE,SAAA,MAGAzE,KAAA0E,KAAA,iBAAAT,EAAAA,EAAA,GAAAK,OAAAtE,KAAAqE,MAGArE,KAAA+E,IAAA/E,KAAAkE,MAAAa,IACA/E,KAAAgF,YAAAhF,KAAAkE,MAAAc,YACAhF,KAAAiF,SAAAjF,KAAAkE,MAAAe,QACA,IAAAjD,gBA3BA4C,EAAA,kBA6BA,GAGA5B,EAAAD,QAAA6B,EAEA5B,EAAAD,QAAAmC,wBAAAxB,EAAA,yCH0CA,EAAE,CAAC,yCAAyC,IAAI,EAAE,CAAC,SAASA,EAAQV,EAAOD,GIjF3E,IAAAoC,EAAAzB,EAAA,6BAEA0B,EACA,CACAC,KAAA,yBAGAC,2BAAA,eACAC,4BAAA,EACAC,gCAAA,EACAC,gCAAA,EAGAC,0BAAA,EACAC,2CAAA,EAEAC,UAAA,CAAA,EAEAC,wBAAA,SAGAxC,EAAA,SAAAyC,GAAAxH,UAAA+E,EAAAyC,GAAA,IAAAC,EAAAvG,aAAA6D,GAEA,SAAAA,EAAAsB,EAAAX,EAAAC,GACA,IAAA+B,EAAA/E,gBAAAjB,KAAAqD,GACA,IAAA4C,EAAAtH,OAAAuH,OAAA,CAAA,EAAAC,KAAAC,MAAAD,KAAAE,UAAAjB,IAAApB,IACAgC,EAAAD,EAAAxF,KAAAP,KAAA2E,EAAAsB,EAAAhC,IACAG,YAAA,kBAGA4B,EAAAM,KAAAN,EAAA9B,MAEA8B,EAAAO,QAAAP,EAAA9B,MAAAqC,QAEAP,EAAAQ,qBAAA,EACAR,EAAAS,qBAAA,EACAT,EAAAU,+BAAA,EACAV,EAAAW,6BAAA,EAGA,IAAAC,EAAAjI,OAAAkI,KAAAb,EAAA7B,QAAAyB,WACA,GAAAgB,EAAApF,OAAA,EAEA,IAAA,IAAAD,EAAA,EAAAA,EAAAqF,EAAApF,OAAAD,IACA,CAEA,IAAAuF,EAAAF,EAAArF,GACAyE,EAAA9B,MAAA6C,eAAAC,2BAAA,WAAAhB,EAAA7B,QAAAyB,UAAAkB,GAAAA,EACA,CACA,OAAAd,CACA,CAohBA,OAhhBAnE,aAAAwB,EAAA,CAAA,CAAAzB,IAAA,gBAAA9C,MACA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,qBAEA,CACA,GAAA,CAAAzD,IAAA,qBAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAAoH,gBACAD,GACA,GAAA,CAAAvF,IAAA,UAAA9C,MAEA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,eAEA,CACA,GAAA,CAAAzD,IAAA,eAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAAqH,UACAF,GACA,GAAA,CAAAvF,IAAA,QAAA9C,MAEA,WAEAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,mCAEArF,KAAAoH,gBAIA,IAFA,IAAAE,EAAA3I,OAAAkI,KAAA7G,KAAAsG,KAAAiB,OACAC,EAAA,GACAjG,EAAA,EAAAA,EAAA+F,EAAA9F,OAAAD,IACA,CACA,IAAAkG,EAAAzH,KAAAsG,KAAAiB,MAAAD,EAAA/F,IACAkG,EAAAtD,QAAAuD,gBAEAF,EAAAG,KAAAF,EAEA,CAEAD,EAAAI,MAAA,SAAAhE,EAAAiE,GAAA,OAAAjE,EAAAO,QAAA2D,sBAAAD,EAAA1D,QAAA2D,qBAAA,IACA,IAAA,IAAAvG,EAAA,EAAAA,EAAAiG,EAAAhG,OAAAD,IAEAiG,EAAAjG,GAAAwG,QAKA,OAHA/H,KAAAqH,UACArH,KAAAgI,eACAhI,KAAAyG,oBAAAzG,KAAAkE,MAAAa,IAAAkD,gBACA,CACA,GAAA,CAAArG,IAAA,aAAA9C,MACA,SAAAqI,GACA,IAAAe,EAAAlI,KACAmI,EAAAnI,KAAAkE,MAAA6C,eAAAqB,8CAAA,cAEAD,EAAAE,WAAArI,KAAAsI,mBAAAhJ,KAAAU,OAIA,IAFA,IAAAsH,EAAA3I,OAAAkI,KAAA7G,KAAAsG,KAAAiB,OACAC,EAAA,GACAjG,EAAA,EAAAA,EAAA+F,EAAA9F,OAAAD,IACA,CACA,IAAAkG,EAAAzH,KAAAsG,KAAAiB,MAAAD,EAAA/F,IACAkG,EAAAtD,QAAAoE,kBAEAf,EAAAG,KAAAF,EAEA,CAEAD,EAAAI,MAAA,SAAAhE,EAAAiE,GAAA,OAAAjE,EAAAO,QAAAqE,iBAAAX,EAAA1D,QAAAqE,gBAAA,IACA,IAAA,IAAAjH,EAAA,EAAAA,EAAAiG,EAAAhG,OAAAD,IAEA4G,EAAAE,WAAAb,EAAAjG,GAAAkH,WAAAnJ,KAAAkI,EAAAjG,KAEA4G,EAAAE,WAAArI,KAAA0I,aAAApJ,KAAAU,OACAmI,EAAAE,WAAArI,KAAA2I,kBAAArJ,KAAAU,OAEAmI,EAAAS,MACA,SAAAC,GAOA,OALAX,EAAA5B,KAAAW,aAAA,GAEAiB,EAAAnD,IAAAmC,MAAA,YAAA5C,OAAA4D,EAAA7D,KAAA,QAAAC,OAAA4D,EAAAxD,KAAA,MAAAJ,OAAA4D,EAAA/D,QAAAkB,KAAA,4BAEA6C,EAAAzB,oBAAAyB,EAAAhE,MAAAa,IAAAkD,eACAd,EAAA0B,EACA,GACA,GAAA,CAAAjH,IAAA,eAAA9C,MAEA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,oBAEA,CACA,GAAA,CAAAzD,IAAA,oBAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAAgI,eACAb,GACA,GAIA,CAAAvF,IAAA,qBAAA9C,MACA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,0BAEA,CACA,GAAA,CAAAzD,IAAA,0BAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAA8I,qBACA3B,GACA,GAAA,CAAAvF,IAAA,eAAA9C,MAEA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,oBAEA,CACA,GAAA,CAAAzD,IAAA,oBAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAA+I,eACA5B,GACA,GAAA,CAAAvF,IAAA,aAAA9C,MAEA,WAEA,GAAAkB,KAAAwG,oBA+CA,OADAxG,KAAA+E,IAAAiE,KAAA,YAAA1E,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,4EACA,EA7CArF,KAAA8I,qBACA9I,KAAA+I,eAIA,IAFA,IAAAzB,EAAA3I,OAAAkI,KAAA7G,KAAAsG,KAAAiB,OACA0B,EAAA,GACA1H,EAAA,EAAAA,EAAA+F,EAAA9F,OAAAD,IACA,CACA,IAAAkG,EAAAzH,KAAAsG,KAAAiB,MAAAD,EAAA/F,IACAkG,EAAAtD,QAAAuD,gBAEAuB,EAAAtB,KAAAF,EAEA,CAEAwB,EAAArB,MAAA,SAAAhE,EAAAiE,GAAA,OAAAjE,EAAAO,QAAA2D,sBAAAD,EAAA1D,QAAA2D,qBAAA,IACA,IAAA,IAAAvG,EAAA,EAAAA,EAAA0H,EAAAzH,OAAAD,IAEA0H,EAAA1H,GAAA2H,aAuBA,OArBAlJ,KAAAmJ,oBACAnJ,KAAAmE,QAAAuB,2BAEA1F,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,0CAGArF,KAAA+H,SAGA/H,KAAAmE,QAAAwB,4CAEA3F,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,4CAGArF,KAAAoJ,UAEApJ,KAAAwG,oBAAAxG,KAAAkE,MAAAa,IAAAkD,gBACA,CAOA,GAAA,CAAArG,IAAA,kBAAA9C,MACA,SAAAuK,GACA,IAAAC,EAAAtJ,KACA,GAAAA,KAAAwG,oBAkEA,OAFAxG,KAAA+E,IAAAiE,KAAA,YAAA1E,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,iFAEA8B,YAhEA,IAAAgB,EAAAnI,KAAAkE,MAAA6C,eAAAqB,8CAAA,cAEApI,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,iCAGA8C,EAAAE,WAAArI,KAAAuJ,wBAAAjK,KAAAU,OACAmI,EAAAE,WAAArI,KAAAwJ,kBAAAlK,KAAAU,OAKA,IAFA,IAAAsH,EAAA3I,OAAAkI,KAAA7G,KAAAsG,KAAAiB,OACA0B,EAAA,GACA1H,EAAA,EAAAA,EAAA+F,EAAA9F,OAAAD,IACA,CACA,IAAAkG,EAAAzH,KAAAsG,KAAAiB,MAAAD,EAAA/F,IACAkG,EAAAtD,QAAAuD,gBAEAuB,EAAAtB,KAAAF,EAEA,CAGAwB,EAAArB,MAAA,SAAAhE,EAAAiE,GAAA,OAAAjE,EAAAO,QAAA2D,sBAAAD,EAAA1D,QAAA2D,qBAAA,IACA,IAAA,IAAAvG,EAAA,EAAAA,EAAA0H,EAAAzH,OAAAD,IACA,CACA,IAAAkG,EAAAwB,EAAA1H,GACA4G,EAAAE,WAAAZ,EAAAgC,gBAAAnK,KAAAmI,GACA,CACAU,EAAAE,WAAArI,KAAA0J,uBAAApK,KAAAU,OAEAA,KAAAmE,QAAAuB,2BAEA1F,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,2DAEA8C,EAAAE,WAAArI,KAAAyI,WAAAnJ,KAAAU,QAGAA,KAAAmE,QAAAwB,4CAEA3F,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,6DAEA8C,EAAAE,WAAArI,KAAA2J,wBAAArK,KAAAU,QAGAmI,EAAAS,MACA,SAAAC,GAOA,OALAS,EAAA9C,oBAAA8C,EAAApF,MAAAa,IAAAkD,eACAqB,EAAAhD,KAAAW,aAAA,GAEAqC,EAAAvE,IAAAmC,MAAA,YAAA5C,OAAAgF,EAAAjF,KAAA,QAAAC,OAAAgF,EAAA5E,KAAA,MAAAJ,OAAAgF,EAAAnF,QAAAkB,KAAA,8BAEAgE,GACA,GAQA,GAAA,CAAAzH,IAAA,oBAAA9C,MAEA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,yBAEA,CACA,GAAA,CAAAzD,IAAA,yBAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAAmJ,oBACAhC,GACA,GAIA,CAAAvF,IAAA,2BAAA9C,MACA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,gCAEA,CACA,GAAA,CAAAzD,IAAA,gCAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAA4J,2BACAzC,GACA,GAAA,CAAAvF,IAAA,qBAAA9C,MAEA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,0BAEA,CACA,GAAA,CAAAzD,IAAA,0BAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAA6J,qBACA1C,GACA,GAAA,CAAAvF,IAAA,mBAAA9C,MAEA,WAEAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,8CAEArF,KAAA4J,2BAIA,IAFA,IAAAtC,EAAA3I,OAAAkI,KAAA7G,KAAAsG,KAAAiB,OACAuC,EAAA,GACAvI,EAAA,EAAAA,EAAA+F,EAAA9F,OAAAD,IACA,CACA,IAAAkG,EAAAzH,KAAAsG,KAAAiB,MAAAD,EAAA/F,IACAuI,EAAAnC,KAAAF,EACA,CACA,IAAA,IAAAlG,EAAA,EAAAA,EAAAuI,EAAAtI,OAAAD,IAEAuI,EAAAvI,GAAAwI,kBAKA,OAHA/J,KAAA6J,qBACA7J,KAAAgK,0BACAhK,KAAA0G,8BAAA1G,KAAAkE,MAAAa,IAAAkD,gBACA,CACA,GAAA,CAAArG,IAAA,wBAAA9C,MACA,SAAAqI,GACA,IAAA8C,EAAAjK,KACAmI,EAAAnI,KAAAkE,MAAA6C,eAAAqB,8CAAA,cAEAD,EAAAE,WAAArI,KAAAkK,8BAAA5K,KAAAU,OAIA,IAFA,IAAAsH,EAAA3I,OAAAkI,KAAA7G,KAAAsG,KAAAiB,OACAuC,EAAA,GACAvI,EAAA,EAAAA,EAAA+F,EAAA9F,OAAAD,IACA,CACA,IAAAkG,EAAAzH,KAAAsG,KAAAiB,MAAAD,EAAA/F,IACAuI,EAAAnC,KAAAF,EACA,CACA,IAAA,IAAAlG,EAAA,EAAAA,EAAAuI,EAAAtI,OAAAD,IAEA4G,EAAAE,WAAAyB,EAAAvI,GAAA4I,qBAAA7K,KAAAwK,EAAAvI,KAEA4G,EAAAE,WAAArI,KAAAoK,wBAAA9K,KAAAU,OACAmI,EAAAE,WAAArI,KAAAqK,6BAAA/K,KAAAU,OAEAmI,EAAAS,MACA,SAAAC,GAOA,OALAoB,EAAA3D,KAAAW,aAAA,GAEAgD,EAAAlF,IAAAmC,MAAA,YAAA5C,OAAA2F,EAAA5F,KAAA,QAAAC,OAAA2F,EAAAvF,KAAA,MAAAJ,OAAA2F,EAAA9F,QAAAkB,KAAA,uCAEA4E,EAAAvD,8BAAAuD,EAAA/F,MAAAa,IAAAkD,eACAd,EAAA0B,EACA,GACA,GAAA,CAAAjH,IAAA,0BAAA9C,MAEA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,+BAEA,CACA,GAAA,CAAAzD,IAAA,+BAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAAgK,0BACA7C,GACA,GAIA,CAAAvF,IAAA,yBAAA9C,MACA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,8BAEA,CACA,GAAA,CAAAzD,IAAA,8BAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAAsK,yBACAnD,GACA,GAAA,CAAAvF,IAAA,mBAAA9C,MAEA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,wBAEA,CACA,GAAA,CAAAzD,IAAA,wBAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAAuK,mBACApD,GACA,GAAA,CAAAvF,IAAA,iBAAA9C,MAEA,WAEAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,4CAEArF,KAAAsK,yBAIA,IAFA,IAAAhD,EAAA3I,OAAAkI,KAAA7G,KAAAsG,KAAAiB,OACAiD,EAAA,GACAjJ,EAAA,EAAAA,EAAA+F,EAAA9F,OAAAD,IACA,CACA,IAAAkG,EAAAzH,KAAAsG,KAAAiB,MAAAD,EAAA/F,IACAiJ,EAAA7C,KAAAF,EACA,CACA,IAAA,IAAAlG,EAAA,EAAAA,EAAAiJ,EAAAhJ,OAAAD,IAEAiJ,EAAAjJ,GAAAkJ,gBAKA,OAHAzK,KAAAuK,mBACAvK,KAAA0K,wBACA1K,KAAA2G,4BAAA3G,KAAAkE,MAAAa,IAAAkD,gBACA,CACA,GAAA,CAAArG,IAAA,sBAAA9C,MACA,SAAAqI,GACA,IAAAwD,EAAA3K,KACAmI,EAAAnI,KAAAkE,MAAA6C,eAAAqB,8CAAA,cAEAD,EAAAE,WAAArI,KAAA4K,4BAAAtL,KAAAU,OAIA,IAFA,IAAAsH,EAAA3I,OAAAkI,KAAA7G,KAAAsG,KAAAiB,OACAiD,EAAA,GACAjJ,EAAA,EAAAA,EAAA+F,EAAA9F,OAAAD,IACA,CACA,IAAAkG,EAAAzH,KAAAsG,KAAAiB,MAAAD,EAAA/F,IACAiJ,EAAA7C,KAAAF,EACA,CACA,IAAA,IAAAlG,EAAA,EAAAA,EAAAiJ,EAAAhJ,OAAAD,IAEA4G,EAAAE,WAAAmC,EAAAjJ,GAAAsJ,mBAAAvL,KAAAkL,EAAAjJ,KAEA4G,EAAAE,WAAArI,KAAA8K,sBAAAxL,KAAAU,OACAmI,EAAAE,WAAArI,KAAA+K,2BAAAzL,KAAAU,OAEAmI,EAAAS,MACA,SAAAC,GAOA,OALA8B,EAAArE,KAAAW,aAAA,GAEA0D,EAAA5F,IAAAmC,MAAA,YAAA5C,OAAAqG,EAAAtG,KAAA,QAAAC,OAAAqG,EAAAjG,KAAA,MAAAJ,OAAAqG,EAAAxG,QAAAkB,KAAA,qCAEAsF,EAAAhE,4BAAAgE,EAAAzG,MAAAa,IAAAkD,eACAd,EAAA0B,EACA,GACA,GAAA,CAAAjH,IAAA,wBAAA9C,MAEA,WAMA,OAJAkB,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAAmC,MAAA,YAAA5C,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,6BAEA,CACA,GAAA,CAAAzD,IAAA,6BAAA9C,MACA,SAAAqI,GAGA,OADAnH,KAAA0K,wBACAvD,GACA,GAIA,CAAAvF,IAAA,SAAA9C,MACA,SAAAkM,EAAAC,EAAAC,EAAAC,GAEA,IAAAC,OAAA,IAAAJ,EAAAhL,KAAAmE,QAAAmB,2BAAA0F,EACAK,OAAA,IAAAJ,EAAAjL,KAAAmE,QAAAoB,2BAAA0F,EACAK,OAAA,IAAAJ,EAAAlL,KAAAmE,QAAAqB,+BAAA0F,EACAK,OAAA,IAAAJ,EAAAnL,KAAAmE,QAAAsB,+BAAA0F,EAGA1D,EAAA,iBAAA2D,GAAApL,KAAAgF,YAAAwG,SAAAJ,GACA,OAAA3D,EAMAA,EAAA2B,OAAAiC,EAAAC,EAAAC,IAJAvL,KAAA+E,IAAA0G,MAAA,YAAAnH,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,gCAAAf,OAAA8G,EAAA,sCACA,EAIA,GAAA,CAAAxJ,IAAA,qBAAA9C,MACA,WAEA,OAAAkB,KAAAoJ,OAAApJ,KAAAmE,QAAAmB,2BAAAtF,KAAAmE,QAAAoB,2BAAAvF,KAAAmE,QAAAqB,+BAAAxF,KAAAmE,QAAAsB,+BACA,GAAA,CAAA7D,IAAA,cAAA9C,MAEA,SAAAkM,EAAAC,EAAAC,EAAAC,EAAAhE,GAEA,IAAAiE,OAAA,IAAAJ,EAAAhL,KAAAmE,QAAAmB,2BAAA0F,EACAK,OAAA,IAAAJ,EAAAjL,KAAAmE,QAAAoB,2BAAA0F,EACAK,OAAA,IAAAJ,EAAAlL,KAAAmE,QAAAqB,+BAAA0F,EACAK,OAAA,IAAAJ,EAAAnL,KAAAmE,QAAAsB,+BAAA0F,EAEA1D,EAAA,iBAAA2D,GAAApL,KAAAgF,YAAAwG,SAAAJ,GACA,IAAA3D,EACA,CACA,IAAAiE,EAAA,YAAApH,OAAAtE,KAAAqE,KAAA,QAAAC,OAAAtE,KAAA0E,KAAA,MAAAJ,OAAAtE,KAAAmE,QAAAkB,KAAA,+CAAAf,OAAA8G,EAAA,oCAKA,OAJApL,KAAAsG,KAAAW,aAAA,GAEAjH,KAAA+E,IAAA0G,MAAAC,GAEAvE,EAAA,IAAAtD,MAAA6H,GACA,CAEA,OAAAjE,EAAAkE,YAAAN,EAAAC,EAAAC,EAAApE,EACA,GAAA,CAAAvF,IAAA,0BAAA9C,MACA,SAAAqI,GAEA,OAAAnH,KAAA2L,YAAA3L,KAAAmE,QAAAmB,2BAAAtF,KAAAmE,QAAAoB,2BAAAvF,KAAAmE,QAAAqB,+BAAAxF,KAAAmE,QAAAsB,+BAAA0B,EACA,KAAA9D,CAAA,CAjjBA,CAAA8B,GAojBAnC,EAAAD,QAAAM,CJmFA,EAAE,CAAC,4BAA4B,KAAK,CAAC,EAAE,CAAC,GC5pBxC,CD4pB4C,EAC5C","file":"pict-application.compatible.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PictApplication = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n\n},{}],2:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.servicesMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');\n},{\"./Fable-ServiceProviderBase-Preinit.js\":1}],3:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase')\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\nclass PictApplication extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tthis.serviceType = 'PictApplication';\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\tthis.initializeTimestamp = false;\n\t\tthis.lastSolvedTimestamp = false;\n\t\tthis.lastMarshalFromViewsTimestamp = false;\n\t\tthis.lastMarshalToViewsTimestamp = false;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.serviceManager.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\tinitializeAsync(fCallBack)\n\t{\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn fCallBack();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\t}\n\trenderMainViewport()\n\t{\n\t\treturn this.render(this.options.MainViewportViewIdentifier, this.options.MainViewportRenderableHash, this.options.MainViewportDestinationAddress, this.options.MainViewportDefaultDataAddress);\n\t}\n\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn fCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\treturn tmpView.renderAsync(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, fCallback);\n\t}\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\treturn this.renderAsync(this.options.MainViewportViewIdentifier, this.options.MainViewportRenderableHash, this.options.MainViewportDestinationAddress, this.options.MainViewportDefaultDataAddress, fCallback);\n\t}\n}\n\nmodule.exports = PictApplication;\n},{\"fable-serviceproviderbase\":2}]},{},[3])(3)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.servicesMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');","const libFableServiceBase = require('fable-serviceproviderbase')\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\nclass PictApplication extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tthis.serviceType = 'PictApplication';\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\tthis.initializeTimestamp = false;\n\t\tthis.lastSolvedTimestamp = false;\n\t\tthis.lastMarshalFromViewsTimestamp = false;\n\t\tthis.lastMarshalToViewsTimestamp = false;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.serviceManager.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\tinitializeAsync(fCallBack)\n\t{\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn fCallBack();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn fCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn fCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\t}\n\trenderMainViewport()\n\t{\n\t\treturn this.render(this.options.MainViewportViewIdentifier, this.options.MainViewportRenderableHash, this.options.MainViewportDestinationAddress, this.options.MainViewportDefaultDataAddress);\n\t}\n\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) === 'undefined') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) === 'undefined') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) === 'undefined') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) === 'undefined') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn fCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\treturn tmpView.renderAsync(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, fCallback);\n\t}\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\treturn this.renderAsync(this.options.MainViewportViewIdentifier, this.options.MainViewportRenderableHash, this.options.MainViewportDestinationAddress, this.options.MainViewportDefaultDataAddress, fCallback);\n\t}\n}\n\nmodule.exports = PictApplication;"]}