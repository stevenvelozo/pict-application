{"version":3,"sources":["pict-application.compatible.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","source/Pict-Application.js"],"names":["_callSuper","t","o","e","_getPrototypeOf","_possibleConstructorReturn","_isNativeReflectConstruct","Reflect","construct","constructor","apply","_typeof","TypeError","_assertThisInitialized","ReferenceError","Boolean","prototype","valueOf","call","Object","setPrototypeOf","getPrototypeOf","bind","__proto__","_inherits","create","value","writable","configurable","defineProperty","_setPrototypeOf","_classCallCheck","a","n","_defineProperties","r","length","enumerable","_toPropertyKey","key","_createClass","_defineProperty","i","_toPrimitive","Symbol","toPrimitive","String","Number","iterator","f","exports","module","define","amd","window","global","self","this","PictApplication","c","require","u","Error","code","p","FableServiceProviderBase","pFable","pOptions","pServiceHash","isFable","connectFable","fable","UUID","getUUID","options","concat","Math","floor","random","serviceType","Hash","tmpErrorMessage","console","log","Logging","services","servicesMap","CoreServiceProviderBase","libFableServiceBase","defaultPictSettings","Name","MainViewportViewIdentifier","MainViewportRenderableHash","MainViewportDestinationAddress","MainViewportDefaultDataAddress","AutoSolveAfterInitialize","AutoRenderMainViewportViewAfterInitialize","AutoRenderViewsAfterInitialize","ConfigurationOnlyViews","Manifests","IdentifierAddressPrefix","_libFableServiceBase","_this","assign","JSON","parse","stringify","pict","AppData","initializeTimestamp","lastSolvedTimestamp","lastMarshalFromViewsTimestamp","lastMarshalToViewsTimestamp","lastAutoRenderTimestamp","tmpManifestKeys","keys","tmpManifestKey","instantiateServiceProvider","LogNoisiness","trace","fCallback","onPreSolve","onBeforeSolve","onSolve","tmpLoadedProviders","providers","tmpProvidersToSolve","tmpProvider","AutoSolveWithApp","push","sort","b","AutoSolveOrdinal","solve","tmpLoadedViews","views","tmpViewsToSolve","tmpView","AutoInitialize","AutoInitializeOrdinal","onAfterSolve","getTimeStamp","_this2","tmpAnticipate","instantiateServiceProviderWithoutRegistration","anticipate","onBeforeSolveAsync","tmpCallback","warn","pError","error","solveAsync","onSolveAsync","onAfterSolveAsync","wait","onBeforeInitialize","onInitialize","LogControlFlow","tmpViewIdentifier","ViewIdentifier","info","addView","tmpProvidersToInitialize","initialize","tmpViewsToInitialize","onAfterInitialize","render","_this3","onBeforeInitializeAsync","onInitializeAsync","initializeAsync","onAfterInitializeAsync","renderMainViewportAsync","onBeforeMarshalFromViews","onMarshalFromViews","tmpViewsToMarshalFromViews","marshalFromView","onAfterMarshalFromViews","_this4","onBeforeMarshalFromViewsAsync","marshalFromViewAsync","onMarshalFromViewsAsync","onAfterMarshalFromViewsAsync","onBeforeMarshalToViews","onMarshalToViews","tmpViewsToMarshalToViews","marshalToView","onAfterMarshalToViews","_this5","onBeforeMarshalToViewsAsync","marshalToViewAsync","onMarshalToViewsAsync","onAfterMarshalToViewsAsync","onBeforeRender","pViewIdentifier","pRenderableHash","pRenderDestinationAddress","pTemplateDataAddress","tmpRenderableHash","tmpRenderDestinationAddress","tmpTemplateDataAddress","PictView","onRender","onAfterRender","_this6","tmpRenderAnticipate","newAnticipate","onBeforeRenderAsync","onRenderAsync","fNext","renderAsync","onAfterRenderAsync","_this7","AutoRenderOrdinal","AutoRender","_this8","get"],"mappings":"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","file":"pict-application.compatible.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PictApplication = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;\n},{}],2:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase')\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport and other autorender views after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\t\tAutoRenderViewsAfterInitialize: false,\n\n\t\tConfigurationOnlyViews: [],\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\nclass PictApplication extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tthis.serviceType = 'PictApplication';\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\tthis.initializeTimestamp = false;\n\t\tthis.lastSolvedTimestamp = false;\n\t\tthis.lastMarshalFromViewsTimestamp = false;\n\t\tthis.lastMarshalToViewsTimestamp = false;\n\t\tthis.lastAutoRenderTimestamp = false;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\tonPreSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonPreSolveAsync(fCallback)\n\t{\n\t\tthis.onPreSolve();\n\t\treturn fCallback();\n\t}\n\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpProvidersToSolve[i].solve(tmpProvidersToSolve[i]);\n\t\t}\n\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvidersToSolve[i].solveAsync.bind(tmpProvidersToSolve[i]));\n\t\t}\n\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}` \n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.onInitialize();\n\n\t\t\t// Walk through any loaded providers and initialize them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpProvidersToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);\n\t\t}\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}` \n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\n\t\t\t// Walk through any loaded providers and solve them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpProvidersToInitialize[i].initializeAsync.bind(tmpProvidersToInitialize[i]));\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn tmpCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\tthis.onBeforeRender();\n\t\treturn fCallback();\n\t}\n\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] render:`);\n\t\t}\n\n\t\tthis.onBeforeRender();\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.onRender();\n\n\t\ttmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\n\t\tthis.onAfterRender();\n\n\t\treturn true;\n\t}\n\tonRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonRenderAsync(fCallback)\n\t{\n\t\tthis.onRender();\n\t\treturn fCallback();\n\t}\n\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] renderAsync:`);\n\t\t}\n\n\t\tlet tmpRenderAnticipate = this.fable.newAnticipate();\n\n\t\ttmpRenderAnticipate.anticipate(this.onBeforeRenderAsync.bind(this));\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn tmpCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\ttmpRenderAnticipate.anticipate(this.onRenderAsync.bind(this));\n\n\t\ttmpRenderAnticipate.anticipate(\n\t\t\t(fNext) =>\n\t\t\t{\n\t\t\t\ttmpView.renderAsync.call(tmpView, tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, fNext);\n\t\t\t});\n\n\t\ttmpRenderAnticipate.anticipate(this.onAfterRenderAsync.bind(this));\n\n\t\treturn tmpRenderAnticipate.wait(tmpCallback);\n\t}\n\n\tonAfterRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\tthis.onAfterRender();\n\t\treturn fCallback();\n\t}\n\n\n\trenderMainViewport()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`);\n\t\t}\n\n\t\treturn this.render();\n\t}\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`);\n\t\t}\n\n\t\treturn this.renderAsync(fCallback);\n\t}\n\trenderAutoViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);\n\t\t}\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpView.render();\n\t\t\t}\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t}\n\t}\n\trenderAutoViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);\n\t\t}\n\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpView.renderAsync.bind(tmpView));\n\t\t\t}\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.lastAutoRenderTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t\t\t}\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tget isPictApplication()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictApplication;\n},{\"fable-serviceproviderbase\":1}]},{},[2])(2)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;","const libFableServiceBase = require('fable-serviceproviderbase')\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport and other autorender views after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\t\tAutoRenderViewsAfterInitialize: false,\n\n\t\tConfigurationOnlyViews: [],\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\nclass PictApplication extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tthis.serviceType = 'PictApplication';\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\tthis.initializeTimestamp = false;\n\t\tthis.lastSolvedTimestamp = false;\n\t\tthis.lastMarshalFromViewsTimestamp = false;\n\t\tthis.lastMarshalToViewsTimestamp = false;\n\t\tthis.lastAutoRenderTimestamp = false;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\tonPreSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonPreSolveAsync(fCallback)\n\t{\n\t\tthis.onPreSolve();\n\t\treturn fCallback();\n\t}\n\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpProvidersToSolve[i].solve(tmpProvidersToSolve[i]);\n\t\t}\n\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvidersToSolve[i].solveAsync.bind(tmpProvidersToSolve[i]));\n\t\t}\n\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}` \n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.onInitialize();\n\n\t\t\t// Walk through any loaded providers and initialize them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpProvidersToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);\n\t\t}\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}` \n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\n\t\t\t// Walk through any loaded providers and solve them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpProvidersToInitialize[i].initializeAsync.bind(tmpProvidersToInitialize[i]));\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn tmpCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\tthis.onBeforeRender();\n\t\treturn fCallback();\n\t}\n\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] render:`);\n\t\t}\n\n\t\tthis.onBeforeRender();\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.onRender();\n\n\t\ttmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\n\t\tthis.onAfterRender();\n\n\t\treturn true;\n\t}\n\tonRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonRenderAsync(fCallback)\n\t{\n\t\tthis.onRender();\n\t\treturn fCallback();\n\t}\n\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] renderAsync:`);\n\t\t}\n\n\t\tlet tmpRenderAnticipate = this.fable.newAnticipate();\n\n\t\ttmpRenderAnticipate.anticipate(this.onBeforeRenderAsync.bind(this));\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn tmpCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\ttmpRenderAnticipate.anticipate(this.onRenderAsync.bind(this));\n\n\t\ttmpRenderAnticipate.anticipate(\n\t\t\t(fNext) =>\n\t\t\t{\n\t\t\t\ttmpView.renderAsync.call(tmpView, tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, fNext);\n\t\t\t});\n\n\t\ttmpRenderAnticipate.anticipate(this.onAfterRenderAsync.bind(this));\n\n\t\treturn tmpRenderAnticipate.wait(tmpCallback);\n\t}\n\n\tonAfterRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\tthis.onAfterRender();\n\t\treturn fCallback();\n\t}\n\n\n\trenderMainViewport()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`);\n\t\t}\n\n\t\treturn this.render();\n\t}\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`);\n\t\t}\n\n\t\treturn this.renderAsync(fCallback);\n\t}\n\trenderAutoViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);\n\t\t}\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpView.render();\n\t\t\t}\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t}\n\t}\n\trenderAutoViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);\n\t\t}\n\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpView.renderAsync.bind(tmpView));\n\t\t\t}\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.lastAutoRenderTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t\t\t}\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tget isPictApplication()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictApplication;"]}