{"version":3,"sources":["pict-application.compatible.min.js","node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","source/Pict-Application.js"],"names":["_callSuper","t","o","e","_getPrototypeOf","_possibleConstructorReturn","_isNativeReflectConstruct","Reflect","construct","constructor","apply","self","call","_typeof","TypeError","_assertThisInitialized","ReferenceError","Boolean","prototype","valueOf","Object","setPrototypeOf","getPrototypeOf","bind","__proto__","_inherits","subClass","superClass","create","value","writable","configurable","defineProperty","_setPrototypeOf","p","_classCallCheck","instance","Constructor","_defineProperties","target","props","i","length","descriptor","enumerable","_toPropertyKey","key","_createClass","protoProps","staticProps","_defineProperty","obj","_toPrimitive","String","r","Symbol","toPrimitive","Number","iterator","f","exports","module","define","amd","window","global","this","PictApplication","n","c","require","u","a","Error","code","FableServiceProviderBase","pFable","pOptions","pServiceHash","isFable","connectFable","fable","UUID","getUUID","options","concat","Math","floor","random","serviceType","Hash","tmpErrorMessage","console","log","Logging","services","servicesMap","CoreServiceProviderBase","libFableServiceBase","defaultPictSettings","Name","MainViewportViewIdentifier","MainViewportRenderableHash","MainViewportDestinationAddress","MainViewportDefaultDataAddress","AutoSolveAfterInitialize","AutoRenderMainViewportViewAfterInitialize","AutoRenderViewsAfterInitialize","Manifests","IdentifierAddressPrefix","_libFableServiceBase","_this","assign","JSON","parse","stringify","pict","AppData","initializeTimestamp","lastSolvedTimestamp","lastMarshalFromViewsTimestamp","lastMarshalToViewsTimestamp","lastAutoRenderTimestamp","tmpManifestKeys","keys","tmpManifestKey","instantiateServiceProvider","LogNoisiness","trace","fCallback","onPreSolve","onBeforeSolve","onSolve","tmpLoadedProviders","providers","tmpProvidersToSolve","tmpProvider","AutoSolveWithApp","push","sort","b","AutoSolveOrdinal","solve","tmpLoadedViews","views","tmpViewsToSolve","tmpView","AutoInitialize","AutoInitializeOrdinal","onAfterSolve","getTimeStamp","_this2","tmpAnticipate","instantiateServiceProviderWithoutRegistration","anticipate","onBeforeSolveAsync","tmpCallback","warn","pError","error","solveAsync","onSolveAsync","onAfterSolveAsync","wait","onBeforeInitialize","onInitialize","LogControlFlow","tmpProvidersToInitialize","initialize","tmpViewsToInitialize","onAfterInitialize","render","_this3","onBeforeInitializeAsync","onInitializeAsync","initializeAsync","onAfterInitializeAsync","renderMainViewportAsync","onBeforeMarshalFromViews","onMarshalFromViews","tmpViewsToMarshalFromViews","marshalFromView","onAfterMarshalFromViews","_this4","onBeforeMarshalFromViewsAsync","marshalFromViewAsync","onMarshalFromViewsAsync","onAfterMarshalFromViewsAsync","onBeforeMarshalToViews","onMarshalToViews","tmpViewsToMarshalToViews","marshalToView","onAfterMarshalToViews","_this5","onBeforeMarshalToViewsAsync","marshalToViewAsync","onMarshalToViewsAsync","onAfterMarshalToViewsAsync","pViewIdentifier","pRenderableHash","pRenderDestinationAddress","pTemplateDataAddress","tmpViewIdentifier","tmpRenderableHash","tmpRenderDestinationAddress","tmpTemplateDataAddress","PictView","_this6","renderAsync","_this7","AutoRenderOrdinal","AutoRender","_this8"],"mappings":"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","file":"pict-application.compatible.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PictApplication = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;\n},{}],2:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase')\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport and other autorender views after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\t\tAutoRenderViewsAfterInitialize: false,\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\nclass PictApplication extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tthis.serviceType = 'PictApplication';\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\tthis.initializeTimestamp = false;\n\t\tthis.lastSolvedTimestamp = false;\n\t\tthis.lastMarshalFromViewsTimestamp = false;\n\t\tthis.lastMarshalToViewsTimestamp = false;\n\t\tthis.lastAutoRenderTimestamp = false;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\tonPreSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonPreSolveAsync(fCallback)\n\t{\n\t\tthis.onPreSolve();\n\t\treturn fCallback();\n\t}\n\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpProvidersToSolve[i].solve(tmpProvidersToSolve[i]);\n\t\t}\n\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvidersToSolve[i].solveAsync.bind(tmpProvidersToSolve[i]));\n\t\t}\n\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\n\t\t\t// Walk through any loaded providers and initialize them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpProvidersToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);\n\t\t}\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\n\t\t\t// Walk through any loaded providers and solve them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpProvidersToInitialize[i].initializeAsync.bind(tmpProvidersToInitialize[i]));\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn tmpCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] render:`);\n\t\t}\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\t}\n\trenderMainViewport()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`);\n\t\t}\n\n\t\treturn this.render();\n\t}\n\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] renderAsync:`);\n\t\t}\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn tmpCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\treturn tmpView.renderAsync(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, tmpCallback);\n\t}\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`);\n\t\t}\n\n\t\treturn this.renderAsync(fCallback);\n\t}\n\n\trenderAutoViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);\n\t\t}\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpView.render();\n\t\t\t}\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t}\n\t}\n\trenderAutoViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);\n\t\t}\n\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpView.renderAsync.bind(tmpView));\n\t\t\t}\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.lastAutoRenderTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t\t\t}\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n}\n\nmodule.exports = PictApplication;\n},{\"fable-serviceproviderbase\":1}]},{},[2])(2)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;","const libFableServiceBase = require('fable-serviceproviderbase')\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport and other autorender views after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\t\tAutoRenderViewsAfterInitialize: false,\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\nclass PictApplication extends libFableServiceBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\t\tthis.serviceType = 'PictApplication';\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\tthis.AppData = this.fable.AppData;\n\n\t\tthis.initializeTimestamp = false;\n\t\tthis.lastSolvedTimestamp = false;\n\t\tthis.lastMarshalFromViewsTimestamp = false;\n\t\tthis.lastMarshalToViewsTimestamp = false;\n\t\tthis.lastAutoRenderTimestamp = false;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\tonPreSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonPreSolveAsync(fCallback)\n\t{\n\t\tthis.onPreSolve();\n\t\treturn fCallback();\n\t}\n\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpProvidersToSolve[i].solve(tmpProvidersToSolve[i]);\n\t\t}\n\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvidersToSolve[i].solveAsync.bind(tmpProvidersToSolve[i]));\n\t\t}\n\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\t\t\tthis.onInitialize();\n\n\t\t\t// Walk through any loaded providers and initialize them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpProvidersToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);\n\t\t}\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\n\t\t\t// Walk through any loaded providers and solve them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpProvidersToInitialize[i].initializeAsync.bind(tmpProvidersToInitialize[i]));\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn tmpCallback();\n\t\t}\n\t}\n\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] render:`);\n\t\t}\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn tmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\t}\n\trenderMainViewport()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`);\n\t\t}\n\n\t\treturn this.render();\n\t}\n\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] renderAsync:`);\n\t\t}\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn tmpCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\treturn tmpView.renderAsync(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, tmpCallback);\n\t}\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`);\n\t\t}\n\n\t\treturn this.renderAsync(fCallback);\n\t}\n\n\trenderAutoViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);\n\t\t}\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpView.render();\n\t\t\t}\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t}\n\t}\n\trenderAutoViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) => \n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${pError}`, pError)\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);\n\t\t}\n\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) => \n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpView.renderAsync.bind(tmpView));\n\t\t\t}\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.lastAutoRenderTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t\t\t}\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n}\n\nmodule.exports = PictApplication;"]}