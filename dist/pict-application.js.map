{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/fable-serviceproviderbase/package.json","pict-application.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","package.json","source/Pict-Application.js"],"names":["f","exports","module","define","amd","g","window","global","self","PictApplication","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","libPackage","FableServiceProviderBase","constructor","pFable","pOptions","pServiceHash","isFable","connectFable","fable","_PackageFableServiceProvider","UUID","getUUID","options","Math","floor","random","serviceType","Hash","tmpErrorMessage","console","log","Logging","services","servicesMap","_defineProperty","CoreServiceProviderBase","libFableServiceBase","defaultPictSettings","Name","MainViewportViewIdentifier","MainViewportRenderableHash","MainViewportDestinationAddress","MainViewportDefaultDataAddress","AutoSolveAfterInitialize","AutoRenderMainViewportViewAfterInitialize","AutoRenderViewsAfterInitialize","AutoLoginAfterInitialize","AutoLoadDataAfterLogin","ConfigurationOnlyViews","Manifests","IdentifierAddressPrefix","tmpCarryOverConfiguration","settings","PictApplicationConfiguration","tmpOptions","Object","assign","JSON","parse","stringify","_Package","pict","AppData","Bundle","initializeTimestamp","lastSolvedTimestamp","lastLoginTimestamp","lastMarshalFromViewsTimestamp","lastMarshalToViewsTimestamp","lastAutoRenderTimestamp","lastLoadDataTimestamp","tmpManifestKeys","keys","tmpManifestKey","instantiateServiceProvider","onPreSolve","LogNoisiness","trace","onPreSolveAsync","fCallback","onBeforeSolve","onBeforeSolveAsync","onSolve","onSolveAsync","solve","tmpLoadedProviders","providers","tmpProvidersToSolve","tmpProvider","AutoSolveWithApp","push","sort","b","AutoSolveOrdinal","tmpLoadedViews","views","tmpViewsToSolve","tmpView","AutoInitialize","AutoInitializeOrdinal","onAfterSolve","getTimeStamp","solveAsync","tmpAnticipate","instantiateServiceProviderWithoutRegistration","anticipate","bind","tmpCallback","warn","pError","error","onAfterSolveAsync","wait","onBeforeLoginAsync","onLoginAsync","loginAsync","onAfterLoginAsync","fNext","isLoggedIn","loadDataAsync","onBeforeLoadDataAsync","onLoadDataAsync","tmpProvidersToLoadData","AutoLoadDataWithApp","AutoLoadDataOrdinal","onAfterLoadDataAsync","onBeforeSaveDataAsync","onSaveDataAsync","saveDataAsync","tmpProvidersToSaveData","AutoSaveDataWithApp","AutoSaveDataOrdinal","onAfterSaveDataAsync","lastSaveDataTimestamp","onBeforeInitialize","onBeforeInitializeAsync","onInitialize","onInitializeAsync","initialize","LogControlFlow","tmpViewIdentifier","ViewIdentifier","info","addView","tmpProvidersToInitialize","tmpViewsToInitialize","onAfterInitialize","render","initializeAsync","onAfterInitializeAsync","renderMainViewportAsync","message","stack","onBeforeMarshalFromViews","onBeforeMarshalFromViewsAsync","onMarshalFromViews","onMarshalFromViewsAsync","marshalFromViews","tmpViewsToMarshalFromViews","marshalFromView","onAfterMarshalFromViews","marshalFromViewsAsync","marshalFromViewAsync","onAfterMarshalFromViewsAsync","onBeforeMarshalToViews","onBeforeMarshalToViewsAsync","onMarshalToViews","onMarshalToViewsAsync","marshalToViews","tmpViewsToMarshalToViews","marshalToView","onAfterMarshalToViews","marshalToViewsAsync","marshalToViewAsync","onAfterMarshalToViewsAsync","onBeforeRender","onBeforeRenderAsync","pViewIdentifier","pRenderableHash","pRenderDestinationAddress","pTemplateDataAddress","tmpRenderableHash","tmpRenderDestinationAddress","tmpTemplateDataAddress","PictView","onRender","onAfterRender","onRenderAsync","renderAsync","tmpRenderAnticipate","newAnticipate","onAfterRenderAsync","renderMainViewport","renderAutoViews","AutoRenderOrdinal","AutoRender","renderAutoViewsAsync","isPictApplication"],"mappings":"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","file":"pict-application.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports={\n    \"name\": \"fable-serviceproviderbase\",\n    \"version\": \"3.0.15\",\n    \"description\": \"Simple base classes for fable services.\",\n    \"main\": \"source/Fable-ServiceProviderBase.js\",\n    \"scripts\": {\n        \"start\": \"node source/Fable-ServiceProviderBase.js\",\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase.git\"\n    },\n    \"keywords\": [\n        \"entity\",\n        \"behavior\"\n    ],\n    \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/fable-serviceproviderbase\",\n    \"devDependencies\": {\n        \"fable\": \"^3.0.143\",\n        \"quackage\": \"^1.0.33\"\n    }\n}","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PictApplication = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\nmodule.exports={\n    \"name\": \"fable-serviceproviderbase\",\n    \"version\": \"3.0.15\",\n    \"description\": \"Simple base classes for fable services.\",\n    \"main\": \"source/Fable-ServiceProviderBase.js\",\n    \"scripts\": {\n        \"start\": \"node source/Fable-ServiceProviderBase.js\",\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase.git\"\n    },\n    \"keywords\": [\n        \"entity\",\n        \"behavior\"\n    ],\n    \"author\": \"Steven Velozo <steven@velozo.com> (http://velozo.com/)\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/fable-serviceproviderbase/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/fable-serviceproviderbase\",\n    \"devDependencies\": {\n        \"fable\": \"^3.0.143\",\n        \"quackage\": \"^1.0.33\"\n    }\n}\n},{}],2:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nconst libPackage = require('../package.json');\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// Initialize the services map if it wasn't passed in\n\t\t/** @type {Object} */\n\t\tthis._PackageFableServiceProvider = libPackage;\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;\n},{\"../package.json\":1}],3:[function(require,module,exports){\nmodule.exports={\n    \"name\": \"pict-application\",\n    \"version\": \"1.0.27\",\n    \"description\": \"Application base class for a pict view-based application\",\n    \"main\": \"source/Pict-Application.js\",\n    \"scripts\": {\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"start\": \"node source/Pict-Application.js\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\",\n        \"docker-dev-build\": \"docker build ./ -f Dockerfile_LUXURYCode -t pict-application-image:local\",\n        \"docker-dev-run\": \"docker run -it -d --name pict-application-dev -p 30001:8080 -p 38086:8086 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/pict-application\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" pict-application-image:local\",\n        \"docker-dev-shell\": \"docker exec -it pict-application-dev /bin/bash\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"lint\": \"eslint source/**\",\n        \"types\": \"tsc -p .\"\n    },\n    \"types\": \"types/source/Pict-Application.d.ts\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"git+https://github.com/stevenvelozo/pict-application.git\"\n    },\n    \"author\": \"steven velozo <steven@velozo.com>\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/pict-application/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/pict-application#readme\",\n    \"devDependencies\": {\n        \"@eslint/js\": \"^9.28.0\",\n        \"browser-env\": \"^3.3.0\",\n        \"eslint\": \"^9.28.0\",\n        \"pict\": \"^1.0.272\",\n        \"pict-provider\": \"^1.0.5\",\n        \"pict-view\": \"^1.0.60\",\n        \"quackage\": \"^1.0.41\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"dependencies\": {\n        \"fable-serviceproviderbase\": \"^3.0.15\"\n    }\n}\n\n},{}],4:[function(require,module,exports){\nconst libFableServiceBase = require('fable-serviceproviderbase')\n\nconst libPackage = require('../package.json');\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport and other autorender views after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\t\tAutoRenderViewsAfterInitialize: false,\n\t\tAutoLoginAfterInitialize: false,\n\t\tAutoLoadDataAfterLogin: false,\n\n\t\tConfigurationOnlyViews: [],\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\n/**\n * Base class for pict applications.\n */\nclass PictApplication extends libFableServiceBase\n{\n\t/**\n\t * @param {import('fable')} pFable\n\t * @param {Record<string, any>} [pOptions]\n\t * @param {string} [pServiceHash]\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpCarryOverConfiguration = (typeof(pFable.settings.PictApplicationConfiguration) === 'object') ? pFable.settings.PictApplicationConfiguration : {};\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), tmpCarryOverConfiguration, pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\n\t\t/** @type {any} */\n\t\tthis.options;\n\t\t/** @type {any} */\n\t\tthis.log;\n\t\t/** @type {import('pict') & import('fable')} */\n\t\tthis.fable;\n\t\t/** @type {string} */\n\t\tthis.UUID;\n\t\t/** @type {string} */\n\t\tthis.Hash;\n\t\t/**\n\t\t * @type {{ [key: string]: any }}\n\t\t */\n\t\tthis.servicesMap;\n\n\t\tthis.serviceType = 'PictApplication';\n\t\t/** @type {Record<string, any>} */\n\t\tthis._Package = libPackage;\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\t/** @type {Record<string, any>} */\n\t\tthis.AppData = this.fable.AppData;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.Bundle = this.fable.Bundle;\n\n\t\t/** @type {number} */\n\t\tthis.initializeTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastSolvedTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastLoginTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastMarshalFromViewsTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastMarshalToViewsTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastAutoRenderTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastLoadDataTimestamp;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonPreSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonPreSolveAsync(fCallback)\n\t{\n\t\tthis.onPreSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpProvidersToSolve[i].solve(tmpProvidersToSolve[i]);\n\t\t}\n\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvidersToSolve[i].solveAsync.bind(tmpProvidersToSolve[i]));\n\t\t}\n\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application Login                        */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tloginAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeLoginAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onLoginAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterLoginAsync.bind(this));\n\n\t\t// check and see if we should automatically trigger a data load\n\t\tif (this.options.AutoLoadDataAfterLogin)\n\t\t{\n\t\t\ttmpAnticipate.anticipate((fNext) =>\n\t\t\t{\n\t\t\t\tif (!this.isLoggedIn())\n\t\t\t\t{\n\t\t\t\t\treturn fNext();\n\t\t\t\t}\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto loading data after login...`);\n\t\t\t\t}\n\t\t\t\t//TODO: should data load errors funnel here? this creates a weird coupling between login and data load callbacks\n\t\t\t\tthis.loadDataAsync((pError) =>\n\t\t\t\t{\n\t\t\t\t\tfNext(pError);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastLoginTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Check if the application state is logged in. Defaults to true. Override this method in your application based on login requirements.\n\t *\n\t * @return {boolean}\n\t */\n\tisLoggedIn()\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application LoadData                     */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tloadDataAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeLoadDataAsync.bind(this));\n\n\t\t// Walk through any loaded providers and load their data as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToLoadData = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoLoadDataWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToLoadData.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToLoadData.sort((a, b) => { return a.options.AutoLoadDataOrdinal - b.options.AutoLoadDataOrdinal; });\n\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onBeforeLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onLoadDataAsync.bind(this));\n\n\t\t//TODO: think about ways to parallelize these\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onAfterLoadDataAsync.bind(this));\n\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onAfterLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t/** @param {Error} [pError] */\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastLoadDataTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application SaveData                     */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tsaveDataAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSaveDataAsync.bind(this));\n\n\t\t// Walk through any loaded providers and load their data as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSaveData = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSaveDataWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSaveData.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSaveData.sort((a, b) => { return a.options.AutoSaveDataOrdinal - b.options.AutoSaveDataOrdinal; });\n\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onBeforeSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSaveDataAsync.bind(this));\n\n\t\t//TODO: think about ways to parallelize these\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onAfterSaveDataAsync.bind(this));\n\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onAfterSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t/** @param {Error} [pError] */\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSaveDataTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}`\n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.onInitialize();\n\n\t\t\t// Walk through any loaded providers and initialize them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpProvidersToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);\n\t\t}\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}`\n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\n\t\t\t// Walk through any loaded providers and solve them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpProvidersToInitialize[i].initializeAsync.bind(tmpProvidersToInitialize[i]));\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoLoginAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.loginAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Error: ${pError.message || pError}`, { stack: pError.stack });\n\t\t\t\t\t}\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn tmpCallback();\n\t\t}\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\tthis.onBeforeRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {string} [pViewIdentifier] - The hash of the view to render. By default, the main viewport view is rendered.\n\t * @param {string} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string} [pTemplateDataAddress] - The address where the data for the template is stored.\n\t *\n\t * TODO: Should we support objects for pTemplateDataAddress for parity with pict-view?\n\t */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] render:`);\n\t\t}\n\n\t\tthis.onBeforeRender();\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.onRender();\n\n\t\ttmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\n\t\tthis.onAfterRender();\n\n\t\treturn true;\n\t}\n\t/**\n\t * @return {boolean}\n\t */\n\tonRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonRenderAsync(fCallback)\n\t{\n\t\tthis.onRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {string|((error?: Error) => void)} pViewIdentifier - The hash of the view to render. By default, the main viewport view is rendered. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pRenderableHash] - The hash of the renderable to render. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pRenderDestinationAddress] - The address where the renderable will be rendered. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pTemplateDataAddress] - The address where the data for the template is stored. (or the callback)\n\t * @param {(error?: Error) => void} [fCallback] - The callback, if all other parameters are provided.\n\t *\n\t * TODO: Should we support objects for pTemplateDataAddress for parity with pict-view?\n\t */\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] renderAsync:`);\n\t\t}\n\n\t\tlet tmpRenderAnticipate = this.fable.newAnticipate();\n\n\t\ttmpRenderAnticipate.anticipate(this.onBeforeRenderAsync.bind(this));\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn tmpCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\ttmpRenderAnticipate.anticipate(this.onRenderAsync.bind(this));\n\n\t\ttmpRenderAnticipate.anticipate(\n\t\t\t(fNext) =>\n\t\t\t{\n\t\t\t\ttmpView.renderAsync.call(tmpView, tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, fNext);\n\t\t\t});\n\n\t\ttmpRenderAnticipate.anticipate(this.onAfterRenderAsync.bind(this));\n\n\t\treturn tmpRenderAnticipate.wait(tmpCallback);\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\tthis.onAfterRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\trenderMainViewport()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`);\n\t\t}\n\n\t\treturn this.render();\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`);\n\t\t}\n\n\t\treturn this.renderAsync(fCallback);\n\t}\n\t/**\n\t * @return {void}\n\t */\n\trenderAutoViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);\n\t\t}\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) =>\n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpView.render();\n\t\t\t}\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t}\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\trenderAutoViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);\n\t\t}\n\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) =>\n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpView.renderAsync.bind(tmpView));\n\t\t\t}\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.lastAutoRenderTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t\t\t}\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tget isPictApplication()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictApplication;\n\n},{\"../package.json\":3,\"fable-serviceproviderbase\":2}]},{},[4])(4)\n});\n\n","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nconst libPackage = require('../package.json');\n\nclass FableServiceProviderBase\n{\n\t// The constructor can be used in two ways:\n\t// 1) With a fable, options object and service hash (the options object and service hash are optional)\n\t// 2) With an object or nothing as the first parameter, where it will be treated as the options object\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\t// Check if a fable was passed in; connect it if so\n\t\tif ((typeof(pFable) === 'object') && pFable.isFable)\n\t\t{\n\t\t\tthis.connectFable(pFable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.fable = false;\n\t\t}\n\n\t\t// Initialize the services map if it wasn't passed in\n\t\t/** @type {Object} */\n\t\tthis._PackageFableServiceProvider = libPackage;\n\n\t\t// initialize options and UUID based on whether the fable was passed in or not.\n\t\tif (this.fable)\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// With no fable, check to see if there was an object passed into either of the first two\n\t\t\t// Parameters, and if so, treat it as the options object\n\t\t\tthis.options = ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t\t: (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t\t: {};\n\t\t\tthis.UUID = `CORE-SVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\t// It's expected that the deriving class will set this\n\t\tthis.serviceType = `Unknown-${this.UUID}`;\n\n\t\t// The service hash is used to identify the specific instantiation of the service in the services map\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash \n\t\t\t\t\t: (!this.fable && (typeof(pOptions) === 'string')) ? pOptions\n\t\t\t\t\t: `${this.UUID}`;\n\t}\n\n\tconnectFable(pFable)\n\t{\n\t\tif ((typeof(pFable) !== 'object') || (!pFable.isFable))\n\t\t{\n\t\t\tlet tmpErrorMessage = `Fable Service Provider Base: Cannot connect to Fable, invalid Fable object passed in.  The pFable parameter was a [${typeof(pFable)}].}`;\n\t\t\tconsole.log(tmpErrorMessage);\n\t\t\treturn new Error(tmpErrorMessage);\n\t\t}\n\n\t\tif (!this.fable)\n\t\t{\n\t\t\tthis.fable = pFable;\n\t\t}\n\n\t\tif (!this.log)\n\t\t{\n\t\t\tthis.log = this.fable.Logging;\n\t\t}\n\t\tif (!this.services)\n\t\t{\n\t\t\tthis.services = this.fable.services;\n\t\t}\n\n\t\tif (!this.servicesMap)\n\t\t{\n\t\t\tthis.servicesMap = this.fable.servicesMap;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\n// This is left here in case we want to go back to having different code/base class for \"core\" services\nmodule.exports.CoreServiceProviderBase = FableServiceProviderBase;","module.exports={\n    \"name\": \"pict-application\",\n    \"version\": \"1.0.27\",\n    \"description\": \"Application base class for a pict view-based application\",\n    \"main\": \"source/Pict-Application.js\",\n    \"scripts\": {\n        \"test\": \"npx mocha -u tdd -R spec\",\n        \"start\": \"node source/Pict-Application.js\",\n        \"coverage\": \"npx nyc --reporter=lcov --reporter=text-lcov npx mocha -- -u tdd -R spec\",\n        \"build\": \"npx quack build\",\n        \"docker-dev-build\": \"docker build ./ -f Dockerfile_LUXURYCode -t pict-application-image:local\",\n        \"docker-dev-run\": \"docker run -it -d --name pict-application-dev -p 30001:8080 -p 38086:8086 -v \\\"$PWD/.config:/home/coder/.config\\\"  -v \\\"$PWD:/home/coder/pict-application\\\" -u \\\"$(id -u):$(id -g)\\\" -e \\\"DOCKER_USER=$USER\\\" pict-application-image:local\",\n        \"docker-dev-shell\": \"docker exec -it pict-application-dev /bin/bash\",\n        \"tests\": \"npx mocha -u tdd --exit -R spec --grep\",\n        \"lint\": \"eslint source/**\",\n        \"types\": \"tsc -p .\"\n    },\n    \"types\": \"types/source/Pict-Application.d.ts\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"git+https://github.com/stevenvelozo/pict-application.git\"\n    },\n    \"author\": \"steven velozo <steven@velozo.com>\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/stevenvelozo/pict-application/issues\"\n    },\n    \"homepage\": \"https://github.com/stevenvelozo/pict-application#readme\",\n    \"devDependencies\": {\n        \"@eslint/js\": \"^9.28.0\",\n        \"browser-env\": \"^3.3.0\",\n        \"eslint\": \"^9.28.0\",\n        \"pict\": \"^1.0.272\",\n        \"pict-provider\": \"^1.0.5\",\n        \"pict-view\": \"^1.0.60\",\n        \"quackage\": \"^1.0.41\"\n    },\n    \"mocha\": {\n        \"diff\": true,\n        \"extension\": [\n            \"js\"\n        ],\n        \"package\": \"./package.json\",\n        \"reporter\": \"spec\",\n        \"slow\": \"75\",\n        \"timeout\": \"5000\",\n        \"ui\": \"tdd\",\n        \"watch-files\": [\n            \"source/**/*.js\",\n            \"test/**/*.js\"\n        ],\n        \"watch-ignore\": [\n            \"lib/vendor\"\n        ]\n    },\n    \"dependencies\": {\n        \"fable-serviceproviderbase\": \"^3.0.15\"\n    }\n}\n","const libFableServiceBase = require('fable-serviceproviderbase')\n\nconst libPackage = require('../package.json');\n\nconst defaultPictSettings = (\n\t{\n\t\tName: 'DefaultPictApplication',\n\n\t\t// The main \"viewport\" is the view that is used to host our application\n\t\tMainViewportViewIdentifier: 'Default-View',\n\t\tMainViewportRenderableHash: false,\n\t\tMainViewportDestinationAddress: false,\n\t\tMainViewportDefaultDataAddress: false,\n\n\t\t// Whether or not we should automatically render the main viewport and other autorender views after we initialize the pict application\n\t\tAutoSolveAfterInitialize: true,\n\t\tAutoRenderMainViewportViewAfterInitialize: true,\n\t\tAutoRenderViewsAfterInitialize: false,\n\t\tAutoLoginAfterInitialize: false,\n\t\tAutoLoadDataAfterLogin: false,\n\n\t\tConfigurationOnlyViews: [],\n\n\t\tManifests: {},\n\t\t// The prefix to prepend on all template destination hashes\n\t\tIdentifierAddressPrefix: 'PICT-'\n\t});\n\n/**\n * Base class for pict applications.\n */\nclass PictApplication extends libFableServiceBase\n{\n\t/**\n\t * @param {import('fable')} pFable\n\t * @param {Record<string, any>} [pOptions]\n\t * @param {string} [pServiceHash]\n\t */\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tlet tmpCarryOverConfiguration = (typeof(pFable.settings.PictApplicationConfiguration) === 'object') ? pFable.settings.PictApplicationConfiguration : {};\n\t\tlet tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(defaultPictSettings)), tmpCarryOverConfiguration, pOptions);\n\t\tsuper(pFable, tmpOptions, pServiceHash);\n\n\t\t/** @type {any} */\n\t\tthis.options;\n\t\t/** @type {any} */\n\t\tthis.log;\n\t\t/** @type {import('pict') & import('fable')} */\n\t\tthis.fable;\n\t\t/** @type {string} */\n\t\tthis.UUID;\n\t\t/** @type {string} */\n\t\tthis.Hash;\n\t\t/**\n\t\t * @type {{ [key: string]: any }}\n\t\t */\n\t\tthis.servicesMap;\n\n\t\tthis.serviceType = 'PictApplication';\n\t\t/** @type {Record<string, any>} */\n\t\tthis._Package = libPackage;\n\n\t\t// Convenience and consistency naming\n\t\tthis.pict = this.fable;\n\t\t// Wire in the essential Pict state\n\t\t/** @type {Record<string, any>} */\n\t\tthis.AppData = this.fable.AppData;\n\t\t/** @type {Record<string, any>} */\n\t\tthis.Bundle = this.fable.Bundle;\n\n\t\t/** @type {number} */\n\t\tthis.initializeTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastSolvedTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastLoginTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastMarshalFromViewsTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastMarshalToViewsTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastAutoRenderTimestamp;\n\t\t/** @type {number} */\n\t\tthis.lastLoadDataTimestamp;\n\n\t\t// Load all the manifests for the application\n\t\tlet tmpManifestKeys = Object.keys(this.options.Manifests);\n\t\tif (tmpManifestKeys.length > 0)\n\t\t{\n\t\t\tfor (let i = 0; i < tmpManifestKeys.length; i++)\n\t\t\t{\n\t\t\t\t// Load each manifest\n\t\t\t\tlet tmpManifestKey = tmpManifestKeys[i];\n\t\t\t\tthis.fable.instantiateServiceProvider('Manifest', this.options.Manifests[tmpManifestKey], tmpManifestKey);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Solve All Views                          */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonPreSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onPreSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonPreSolveAsync(fCallback)\n\t{\n\t\tthis.onPreSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeSolveAsync(fCallback)\n\t{\n\t\tthis.onBeforeSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonSolveAsync(fCallback)\n\t{\n\t\tthis.onSolve();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tsolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing solve() function...`)\n\t\t}\n\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpProvidersToSolve[i].solve(tmpProvidersToSolve[i]);\n\t\t}\n\n\t\tthis.onBeforeSolve();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpViewsToSolve[i].solve();\n\t\t}\n\t\tthis.onSolve();\n\t\tthis.onAfterSolve();\n\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tsolveAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSolveAsync.bind(this));\n\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\t// Walk through any loaded providers and solve them as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSolve.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpProvidersToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvidersToSolve[i].solveAsync.bind(tmpProvidersToSolve[i]));\n\t\t}\n\n\t\t// Walk through any loaded views and solve them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToSolve = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoSolveWithApp)\n\t\t\t{\n\t\t\t\ttmpViewsToSolve.push(tmpView);\n\t\t\t}\n\t\t}\n\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpViewsToSolve.sort((a, b) => { return a.options.AutoSolveOrdinal - b.options.AutoSolveOrdinal; });\n\t\tfor (let i = 0; i < tmpViewsToSolve.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToSolve[i].solveAsync.bind(tmpViewsToSolve[i]));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSolveAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterSolveAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} solveAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSolvedTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterSolve()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSolve:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterSolveAsync(fCallback)\n\t{\n\t\tthis.onAfterSolve();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application Login                        */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tloginAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeLoginAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onLoginAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterLoginAsync.bind(this));\n\n\t\t// check and see if we should automatically trigger a data load\n\t\tif (this.options.AutoLoadDataAfterLogin)\n\t\t{\n\t\t\ttmpAnticipate.anticipate((fNext) =>\n\t\t\t{\n\t\t\t\tif (!this.isLoggedIn())\n\t\t\t\t{\n\t\t\t\t\treturn fNext();\n\t\t\t\t}\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto loading data after login...`);\n\t\t\t\t}\n\t\t\t\t//TODO: should data load errors funnel here? this creates a weird coupling between login and data load callbacks\n\t\t\t\tthis.loadDataAsync((pError) =>\n\t\t\t\t{\n\t\t\t\t\tfNext(pError);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loginAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastLoginTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * Check if the application state is logged in. Defaults to true. Override this method in your application based on login requirements.\n\t *\n\t * @return {boolean}\n\t */\n\tisLoggedIn()\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterLoginAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterLoginAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application LoadData                     */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tloadDataAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeLoadDataAsync.bind(this));\n\n\t\t// Walk through any loaded providers and load their data as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToLoadData = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoLoadDataWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToLoadData.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToLoadData.sort((a, b) => { return a.options.AutoLoadDataOrdinal - b.options.AutoLoadDataOrdinal; });\n\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onBeforeLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onLoadDataAsync.bind(this));\n\n\t\t//TODO: think about ways to parallelize these\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onAfterLoadDataAsync.bind(this));\n\n\t\tfor (const tmpProvider of tmpProvidersToLoadData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onAfterLoadDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t/** @param {Error} [pError] */\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} loadDataAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastLoadDataTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterLoadDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterLoadDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Application SaveData                     */\n\t/* -------------------------------------------------------------------------- */\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tsaveDataAsync(fCallback)\n\t{\n\t\tconst tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\tlet tmpCallback = fCallback;\n\n\t\tif (typeof(tmpCallback) !== 'function')\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync Auto Callback Error: ${pError}`, pError);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeSaveDataAsync.bind(this));\n\n\t\t// Walk through any loaded providers and load their data as well.\n\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\tlet tmpProvidersToSaveData = [];\n\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t{\n\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\tif (tmpProvider.options.AutoSaveDataWithApp)\n\t\t\t{\n\t\t\t\ttmpProvidersToSaveData.push(tmpProvider);\n\t\t\t}\n\t\t}\n\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\ttmpProvidersToSaveData.sort((a, b) => { return a.options.AutoSaveDataOrdinal - b.options.AutoSaveDataOrdinal; });\n\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onBeforeSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onSaveDataAsync.bind(this));\n\n\t\t//TODO: think about ways to parallelize these\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onAfterSaveDataAsync.bind(this));\n\n\t\tfor (const tmpProvider of tmpProvidersToSaveData)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpProvider.onAfterSaveDataAsync.bind(tmpProvider));\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t/** @param {Error} [pError] */\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} saveDataAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastSaveDataTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterSaveDataAsync(fCallback)\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterSaveDataAsync:`);\n\t\t}\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Initialize Application                   */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeInitializeAsync(fCallback)\n\t{\n\t\tthis.onBeforeInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonInitializeAsync(fCallback)\n\t{\n\t\tthis.onInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tinitialize()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize:`);\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tthis.onBeforeInitialize();\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}`\n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.onInitialize();\n\n\t\t\t// Walk through any loaded providers and initialize them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpProvidersToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpViewsToInitialize[i].initialize();\n\t\t\t}\n\n\t\t\tthis.onAfterInitialize();\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Solve the template synchronously\n\t\t\t\tthis.solve();\n\t\t\t}\n\t\t\t// Now check and see if we should automatically render as well\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering after initialization...`);\n\t\t\t\t}\n\t\t\t\t// Render the template synchronously\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialize called but initialization is already completed.  Aborting.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tinitializeAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync:`);\n\t\t}\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (!this.initializeTimestamp)\n\t\t{\n\t\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning initialization...`);\n\t\t\t}\n\n\t\t\tif ('ConfigurationOnlyViews' in this.options)\n\t\t\t{\n\t\t\t\t// Load all the configuration only views\n\t\t\t\tfor (let i = 0; i < this.options.ConfigurationOnlyViews.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpViewIdentifier = (typeof(this.options.ConfigurationOnlyViews[i].ViewIdentifier) === 'undefined') ? `AutoView-${this.fable.getUUID()}`\n\t\t\t\t\t\t\t\t\t\t\t: this.options.ConfigurationOnlyViews[i].ViewIdentifier;\n\t\t\t\t\tthis.log.info(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} adding configuration only view: ${tmpViewIdentifier}`);\n\t\t\t\t\tthis.pict.addView(tmpViewIdentifier, this.options.ConfigurationOnlyViews[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onBeforeInitializeAsync.bind(this));\n\t\t\ttmpAnticipate.anticipate(this.onInitializeAsync.bind(this));\n\n\t\t\t// Walk through any loaded providers and solve them as well.\n\t\t\tlet tmpLoadedProviders = Object.keys(this.pict.providers);\n\t\t\tlet tmpProvidersToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedProviders.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpProvider = this.pict.providers[tmpLoadedProviders[i]];\n\t\t\t\tif (tmpProvider.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpProvidersToInitialize.push(tmpProvider);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the providers by their priority (if they are all priority 0, it will end up being add order due to JSON Object Property Key order stuff)\n\t\t\ttmpProvidersToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpProvidersToInitialize.length; i++)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpProvidersToInitialize[i].initializeAsync.bind(tmpProvidersToInitialize[i]));\n\t\t\t}\n\n\t\t\t// Now walk through any loaded views and initialize them as well.\n\t\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t\tlet tmpViewsToInitialize = [];\n\t\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\t\tif (tmpView.options.AutoInitialize)\n\t\t\t\t{\n\t\t\t\t\ttmpViewsToInitialize.push(tmpView);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Sort the views by their priority\n\t\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\t\ttmpViewsToInitialize.sort((a, b) => { return a.options.AutoInitializeOrdinal - b.options.AutoInitializeOrdinal; });\n\t\t\tfor (let i = 0; i < tmpViewsToInitialize.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpView = tmpViewsToInitialize[i];\n\t\t\t\ttmpAnticipate.anticipate(tmpView.initializeAsync.bind(tmpView));\n\t\t\t}\n\n\t\t\ttmpAnticipate.anticipate(this.onAfterInitializeAsync.bind(this));\n\n\t\t\tif (this.options.AutoLoginAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.loginAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoSolveAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto solving (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.solveAsync.bind(this));\n\t\t\t}\n\n\t\t\tif (this.options.AutoRenderMainViewportViewAfterInitialize)\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 1)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} auto rendering (asynchronously) after initialization...`);\n\t\t\t\t}\n\t\t\t\ttmpAnticipate.anticipate(this.renderMainViewportAsync.bind(this));\n\t\t\t}\n\n\t\t\ttmpAnticipate.wait(\n\t\t\t\t(pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initializeAsync Error: ${pError.message || pError}`, { stack: pError.stack });\n\t\t\t\t\t}\n\t\t\t\t\tthis.initializeTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} initialization complete.`);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmpCallback();\n\t\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} async initialize called but initialization is already completed.  Aborting.`);\n\t\t\t// TODO: Should this be an error?\n\t\t\treturn tmpCallback();\n\t\t}\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterInitialize()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterInitialize:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterInitializeAsync(fCallback)\n\t{\n\t\tthis.onAfterInitialize();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data From All Views              */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tmarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalFromViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalFromViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalFromViews[i].marshalFromView();\n\t\t}\n\t\tthis.onMarshalFromViews();\n\t\tthis.onAfterMarshalFromViews();\n\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tmarshalFromViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalFromViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalFromViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalFromViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalFromViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalFromViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalFromViews[i].marshalFromViewAsync.bind(tmpViewsToMarshalFromViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalFromViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalFromViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalFromViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalFromViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterMarshalFromViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalFromViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterMarshalFromViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalFromViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Marshal Data To All Views                */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onBeforeMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tmarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 2)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} executing marshalToViews() function...`)\n\t\t}\n\t\tthis.onBeforeMarshalToViews();\n\t\t// Now walk through any loaded views and initialize them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpViewsToMarshalToViews[i].marshalToView();\n\t\t}\n\t\tthis.onMarshalToViews();\n\t\tthis.onAfterMarshalToViews();\n\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tmarshalToViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback : false;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\ttmpAnticipate.anticipate(this.onBeforeMarshalToViewsAsync.bind(this));\n\t\t// Walk through any loaded views and marshalToViews them as well.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\tlet tmpViewsToMarshalToViews = [];\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\ttmpViewsToMarshalToViews.push(tmpView);\n\t\t}\n\t\tfor (let i = 0; i < tmpViewsToMarshalToViews.length; i++)\n\t\t{\n\t\t\ttmpAnticipate.anticipate(tmpViewsToMarshalToViews[i].marshalToViewAsync.bind(tmpViewsToMarshalToViews[i]));\n\t\t}\n\t\ttmpAnticipate.anticipate(this.onMarshalToViewsAsync.bind(this));\n\t\ttmpAnticipate.anticipate(this.onAfterMarshalToViewsAsync.bind(this));\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tif (this.pict.LogNoisiness > 2)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} marshalToViewsAsync() complete.`);\n\t\t\t\t}\n\t\t\t\tthis.lastMarshalToViewsTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterMarshalToViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterMarshalToViews:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterMarshalToViewsAsync(fCallback)\n\t{\n\t\tthis.onAfterMarshalToViews();\n\t\treturn fCallback();\n\t}\n\n\t/* -------------------------------------------------------------------------- */\n\t/*                     Code Section: Render View                              */\n\t/* -------------------------------------------------------------------------- */\n\t/**\n\t * @return {boolean}\n\t */\n\tonBeforeRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onBeforeRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonBeforeRenderAsync(fCallback)\n\t{\n\t\tthis.onBeforeRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {string} [pViewIdentifier] - The hash of the view to render. By default, the main viewport view is rendered.\n\t * @param {string} [pRenderableHash] - The hash of the renderable to render.\n\t * @param {string} [pRenderDestinationAddress] - The address where the renderable will be rendered.\n\t * @param {string} [pTemplateDataAddress] - The address where the data for the template is stored.\n\t *\n\t * TODO: Should we support objects for pTemplateDataAddress for parity with pict-view?\n\t */\n\trender(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] render:`);\n\t\t}\n\n\t\tthis.onBeforeRender();\n\n\t\t// Now get the view (by hash) from the loaded views\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not render from View ${tmpViewIdentifier} because it is not a valid view.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.onRender();\n\n\t\ttmpView.render(tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress);\n\n\t\tthis.onAfterRender();\n\n\t\treturn true;\n\t}\n\t/**\n\t * @return {boolean}\n\t */\n\tonRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonRenderAsync(fCallback)\n\t{\n\t\tthis.onRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @param {string|((error?: Error) => void)} pViewIdentifier - The hash of the view to render. By default, the main viewport view is rendered. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pRenderableHash] - The hash of the renderable to render. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pRenderDestinationAddress] - The address where the renderable will be rendered. (or the callback)\n\t * @param {string|((error?: Error) => void)} [pTemplateDataAddress] - The address where the data for the template is stored. (or the callback)\n\t * @param {(error?: Error) => void} [fCallback] - The callback, if all other parameters are provided.\n\t *\n\t * TODO: Should we support objects for pTemplateDataAddress for parity with pict-view?\n\t */\n\trenderAsync(pViewIdentifier, pRenderableHash, pRenderDestinationAddress, pTemplateDataAddress, fCallback)\n\t{\n\t\tlet tmpViewIdentifier = (typeof(pViewIdentifier) !== 'string') ? this.options.MainViewportViewIdentifier : pViewIdentifier;\n\t\tlet tmpRenderableHash = (typeof(pRenderableHash) !== 'string') ? this.options.MainViewportRenderableHash : pRenderableHash;\n\t\tlet tmpRenderDestinationAddress = (typeof(pRenderDestinationAddress) !== 'string') ? this.options.MainViewportDestinationAddress : pRenderDestinationAddress;\n\t\tlet tmpTemplateDataAddress = (typeof(pTemplateDataAddress) !== 'string') ? this.options.MainViewportDefaultDataAddress : pTemplateDataAddress;\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\t(typeof(pTemplateDataAddress) === 'function') ? pTemplateDataAddress :\n\t\t\t\t\t\t\t(typeof(pRenderDestinationAddress) === 'function') ? pRenderDestinationAddress :\n\t\t\t\t\t\t\t(typeof(pRenderableHash) === 'function') ? pRenderableHash :\n\t\t\t\t\t\t\t(typeof(pViewIdentifier) === 'function') ? pViewIdentifier :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} VIEW Renderable[${tmpRenderableHash}] Destination[${tmpRenderDestinationAddress}] TemplateDataAddress[${tmpTemplateDataAddress}] renderAsync:`);\n\t\t}\n\n\t\tlet tmpRenderAnticipate = this.fable.newAnticipate();\n\n\t\ttmpRenderAnticipate.anticipate(this.onBeforeRenderAsync.bind(this));\n\n\t\tlet tmpView = (typeof (tmpViewIdentifier) === 'string') ? this.servicesMap.PictView[tmpViewIdentifier] : false;\n\t\tif (!tmpView)\n\t\t{\n\t\t\tlet tmpErrorMessage = `PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} could not asynchronously render from View ${tmpViewIdentifier} because it is not a valid view.`;\n\t\t\tif (this.pict.LogNoisiness > 3)\n\t\t\t{\n\t\t\t\tthis.log.error(tmpErrorMessage);\n\t\t\t}\n\t\t\treturn tmpCallback(new Error(tmpErrorMessage));\n\t\t}\n\n\t\ttmpRenderAnticipate.anticipate(this.onRenderAsync.bind(this));\n\n\t\ttmpRenderAnticipate.anticipate(\n\t\t\t(fNext) =>\n\t\t\t{\n\t\t\t\ttmpView.renderAsync.call(tmpView, tmpRenderableHash, tmpRenderDestinationAddress, tmpTemplateDataAddress, fNext);\n\t\t\t});\n\n\t\ttmpRenderAnticipate.anticipate(this.onAfterRenderAsync.bind(this));\n\n\t\treturn tmpRenderAnticipate.wait(tmpCallback);\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tonAfterRender()\n\t{\n\t\tif (this.pict.LogNoisiness > 3)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} onAfterRender:`);\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\tonAfterRenderAsync(fCallback)\n\t{\n\t\tthis.onAfterRender();\n\t\treturn fCallback();\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\trenderMainViewport()\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewport:`);\n\t\t}\n\n\t\treturn this.render();\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\trenderMainViewportAsync(fCallback)\n\t{\n\t\tif (this.pict.LogControlFlow)\n\t\t{\n\t\t\tthis.log.trace(`PICT-ControlFlow APPLICATION [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderMainViewportAsync:`);\n\t\t}\n\n\t\treturn this.renderAsync(fCallback);\n\t}\n\t/**\n\t * @return {void}\n\t */\n\trenderAutoViews()\n\t{\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViews...`);\n\t\t}\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) =>\n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpView.render();\n\t\t\t}\n\t\t}\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t}\n\t}\n\t/**\n\t * @param {(error?: Error) => void} fCallback\n\t */\n\trenderAutoViewsAsync(fCallback)\n\t{\n\t\tlet tmpAnticipate = this.fable.instantiateServiceProviderWithoutRegistration('Anticipate');\n\n\t\t// Allow the callback to be passed in as the last parameter no matter what\n\t\tlet tmpCallback = (typeof(fCallback) === 'function') ? fCallback :\n\t\t\t\t\t\t\tfalse;\n\n\t\tif (!tmpCallback)\n\t\t{\n\t\t\tthis.log.warn(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync was called without a valid callback.  A callback will be generated but this could lead to race conditions.`);\n\t\t\ttmpCallback = (pError) =>\n\t\t\t\t{\n\t\t\t\t\tif (pError)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.log.error(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync Auto Callback Error: ${pError}`, pError)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\n\t\tif (this.pict.LogNoisiness > 0)\n\t\t{\n\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} beginning renderAutoViewsAsync...`);\n\t\t}\n\n\t\t// Now walk through any loaded views and sort them by the AutoRender ordinal\n\t\t// TODO: Some optimization cleverness could be gained by grouping them into a parallelized async operation, by ordinal.\n\t\tlet tmpLoadedViews = Object.keys(this.pict.views);\n\t\t// Sort the views by their priority\n\t\t// If they are all the default priority 0, it will end up being add order due to JSON Object Property Key order stuff\n\t\ttmpLoadedViews.sort((a, b) =>\n\t\t{\n\t\t\treturn this.pict.views[a].options.AutoRenderOrdinal - this.pict.views[b].options.AutoRenderOrdinal;\n\t\t});\n\t\tfor (let i = 0; i < tmpLoadedViews.length; i++)\n\t\t{\n\t\t\tlet tmpView = this.pict.views[tmpLoadedViews[i]];\n\t\t\tif (tmpView.options.AutoRender)\n\t\t\t{\n\t\t\t\ttmpAnticipate.anticipate(tmpView.renderAsync.bind(tmpView));\n\t\t\t}\n\t\t}\n\n\t\ttmpAnticipate.wait(\n\t\t\t(pError) =>\n\t\t\t{\n\t\t\t\tthis.lastAutoRenderTimestamp = this.fable.log.getTimeStamp();\n\t\t\t\tif (this.pict.LogNoisiness > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.log.trace(`PictApp [${this.UUID}]::[${this.Hash}] ${this.options.Name} renderAutoViewsAsync complete.`);\n\t\t\t\t}\n\t\t\t\treturn tmpCallback(pError);\n\t\t\t});\n\t}\n\n\t/**\n\t * @return {boolean}\n\t */\n\tget isPictApplication()\n\t{\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PictApplication;\n"]}